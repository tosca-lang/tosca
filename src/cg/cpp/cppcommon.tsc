// Copyright (c) 2016 IBM Corporation.

import std::core
import std::string
import std::num
import std::listdef
import std::pairdef
import std::text
import std::language
import std::tuple
import std::path
import std::text::Text4

import core::Core
import core::utils
import cg::cpp::cppenv
import systemdef
import cg::lifetime
import cg::utils

/* Enumerate the kinds of class corresponding to a form */
enum CppFormClassKind
  | CFC_CONS    /* Non variable class  */
  | CFC_VAR     /* Variable class */
  | CFC_VARUSE  /* Variable use class */


// --- Forward declarations

/* Generate data sort, data form and parameterized function forward declarations */
func CppForwardDecls(#decls: List<Core_cdecl_sort>) -> Text4_text_sort
→ TextFoldES(Map((decl) -> CppForwardDecl(decl), #decls))

func CppForwardDecl(Core_cdecl_sort) -> Text4_text_sort

  rule CppForwardDecl(cdecl⟦ data ##csortvars? ##CONSTRUCTOR ( ##cform* ) ⟧)
  → text⟦†⟨CppTemplatePrefix(#csortvars?)⟩
class †⟨SortNameToCppClassName(#CONSTRUCTOR)⟩;†⟨TextFoldES(Map((cform) -> CppForwardForm(#CONSTRUCTOR, #csortvars?, cform), #cform*))⟩⟧

  rule CppForwardDecl(cdecl⟦ ##canno* ##EXTERN? func ##csortvars? ##csort ##CONSTRUCTOR ##csortsdefault? ⟧)
  → CppFunctionDeclD({}, cdecl⟦ ##canno* ##EXTERN? func ##csortvars? ##csort ##CONSTRUCTOR ##csortsdefault? ⟧, TRUE, TRUE)

  rule CppForwardDecl(#cdecl)
  → text⟦⟧

func CppForwardForm(String, List<Core_csortvars_sort>, Core_cform_sort) -> Text4_text_sort

  rule CppForwardForm(#sortname, #csortvars?, cform⟦ ##CONSTRUCTOR ##csortsdefault? ⟧)
  → text⟦†⟨CppTemplatePrefix(#csortvars?)⟩¶class †⟨ParamFormCppClassName(#CONSTRUCTOR, (), CFC_CONS)⟩;⟧

  rule CppForwardForm(#sortname, #csortvars?, cform⟦ allows-variable ⟧)
  → text⟦
†⟨CppTemplatePrefix(#csortvars?)⟩
class †⟨ParamFormCppClassName(#sortname, (), CFC_VAR)⟩;

†⟨CppTemplatePrefix(#csortvars?)⟩
class †⟨ParamFormCppClassName(#sortname, (), CFC_VARUSE)⟩;⟧

// --- Data translation functions

/* Generate a method making new instances of the given form.
   @param `#sortname`
   @param `#csortvars?`
   @param `#cform`
   @param `#def` whether to generate the method definition in addition to its declaration.
*/
func CppMethodNew(String, List<Core_csortvars_sort>, Core_cform_sort, Bool) -> Text4_text_sort

  rule CppMethodNew(#sortname, #csortvars?, cform⟦ ##CONSTRUCTOR ##csortsdefault? ⟧, #def)
  → text⟦†⟨CppTemplatePrefix(#csortvars?)⟩
†⟨CppTypeRefName(#csortvars?, #sortname)⟩ †⟨CppNewMethodName(#CONSTRUCTOR)⟩(tosca::Context& ctx†⟨MaybeCppFormalParams(MaybeSortsDefaultToMaybeSorts(#csortsdefault?), text⟦, ⟧, FALSE)⟩)†⟨
      If(#def, ()->text⟦
{→
return †⟨If(HasSorts(MaybeSortsDefaultToMaybeSorts(#csortsdefault?)),
              ()->text⟦(*new (ctx) †⟨ParamFormCppClassName(#CONSTRUCTOR, #csortvars?, CFC_CONS)⟩(†⟨MaybeCppFormalParams(MaybeSortsDefaultToMaybeSorts(#csortsdefault?), text⟦⟧, TRUE)⟩));⟧,
              ()->text⟦†⟨ParamFormCppClassName(#CONSTRUCTOR, #csortvars?, CFC_CONS)⟩::SINGLETON;⟧)⟩←
}⟧, ()->text⟦;⟧)⟩⟧

  rule CppMethodNew(#sortname, #csortvars?, cform⟦ allows-variable ⟧, #def)
  → text⟦†⟨CppTemplatePrefix(#csortvars?)⟩
†⟨ParamFormCppClassName(#sortname, #csortvars?, CFC_VAR)⟩& †⟨CppFnName(ConcatString("var", #sortname))⟩(tosca::Context& ctx, const std::string& hint)†⟨
      If(#def, ()->text⟦
{→
return *(new (ctx) †⟨ParamFormCppClassName(#sortname, #csortvars?, CFC_VAR)⟩(ctx.MakeGlobalName(hint)));←
}⟧, ()->text⟦;⟧)⟩⟧

/* Generate base lookup method (the 'as' method) for the given form.
   @param `#sortname`
   @param `#csortvars?`
   @param `#cform`
   @param `#def` whether to generate the method definition in additition to its declaration. */
func CppMethodAs(String, List<Core_csortvars_sort>, Core_cform_sort, Bool) -> Text4_text_sort

  rule CppMethodAs(#sortname, #csortvars?, cform⟦ ##CONSTRUCTOR ##csortsdefault? ⟧, #def)
  → text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
†⟨TextIf(Not(#def), ()->text⟦virtual ⟧)⟩Optional<†⟨ParamFormCppClassName(#CONSTRUCTOR, #csortvars?, CFC_CONS)⟩> †⟨CppQualifier(#sortname, #csortvars?, #def)⟩†⟨CppAsMethodName(#CONSTRUCTOR)⟩(tosca::Context& ctx)†⟨
    If(#def, ()->text⟦
{→
return Optional<†⟨ParamFormCppClassName(#CONSTRUCTOR, #csortvars?, CFC_CONS)⟩>::nullopt;←
}⟧, ()->text⟦;⟧)⟩⟧

  rule CppMethodAs(#sortname, #csortvars?, cform⟦ allows-variable ⟧, #def)
  → text⟦⟧

/* Generate typed use method. */
func CppVarMethodUse(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #def:Bool) -> Text4_text_sort
→ text⟦†⟨CppTemplatePrefix(#csortvars?)⟩
†⟨SortNameToCppClassName(#sortname)⟩†⟨MaybeCppTypeArguments(#csortvars?)⟩& †⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩Use(tosca::Context& ctx)†⟨
      If(#def, ()->text⟦
{→
this->AddRef();
return (*new (ctx) †⟨ParamFormCppClassName(#sortname, #csortvars?, CFC_VARUSE)⟩(*this));←
}⟧, ()->text⟦;⟧)⟩⟧

/* Generate untyped use method. */
func CppVarMethodGUse(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #def:Bool) -> Text4_text_sort
→ text⟦†⟨CppTemplatePrefix(#csortvars?)⟩
tosca::Term& †⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩GUse(tosca::Context& ctx)†⟨
      If(#def, ()->text⟦ { return Use(ctx); }⟧, ()->text⟦;⟧)⟩⟧

/* Generate class constructor corresponding to the given `#formname`. */
func CppFormConstructor(#sortname: String, #csortvars?: List<Core_csortvars_sort>, #formname: String, #csorts?: List<Core_csorts_sort>, #def: Bool) -> Text4_text_sort
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
†⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩†⟨FormCppClassName(#formname)⟩(†⟨MaybeCppFormalParams(#csorts?, text⟦⟧, FALSE)⟩)†⟨
    If(#def,
      ()->text⟦†⟨If(HasSorts(#csorts?),
        ()->text⟦: †⟨MaybeCppClassFields(#csorts?, (isvar type index subindex)->CppInitField(isvar, type, index, subindex))⟩⟧,
        ()->text⟦: Ref(true)⟧)⟩{}⟧,
      ()->text⟦;⟧)⟩⟧

/* Generate default class constructor corresponding to the given `#formname`. Only if not a constant, since otherwise it has already been generated. */
func CppFormDefaultConstructor(#sortname: String, #csortvars?: List<Core_csortvars_sort>, #formname: String, #csorts?: List<Core_csorts_sort>, #def: Bool) -> Text4_text_sort
→ TextIf(Not(IsEmpty(MaybeSortsToSorts(#csorts?))), ()->text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
†⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩†⟨FormCppClassName(#formname)⟩()†⟨
    If(#def,
      ()->text⟦†⟨TextIf(HasSorts(#csorts?),
        ()->text⟦: †⟨MaybeCppClassFields(#csorts?, (isvar type index subindex)->CppNullifyField(isvar, type, index, subindex))⟩⟧)⟩{}⟧,
      ()->text⟦;⟧)⟩⟧)

/* Generate class destructor corresponding to the given `#formname`. */
func CppFormDestructor(#sortname: String, #csortvars?: List<Core_csortvars_sort>, #formname: String, #csorts?: List<Core_csorts_sort>, #def: Bool) -> Text4_text_sort
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
†⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩~†⟨FormCppClassName(#formname)⟩()†⟨
    If(#def,
      ()->text⟦¶{→†⟨TextIf(HasSorts(#csorts?),
        ()->text⟦†⟨MaybeCppClassFields(#csorts?, (isvar type index subindex)->CppReleaseField(isvar, type, index, subindex))⟩⟧)⟩←
}⟧,
      ()->text⟦;⟧)⟩⟧


/* Generate static Make function corresponding to the given `#formname`.*/
func CppFormMethodMake(#sortname: String, #csortvars?: List<Core_csortvars_sort>, #formname: String, #csorts?: List<Core_csorts_sort>, #def: Bool) -> Text4_text_sort
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
†⟨TextIf(Not(#def), ()->text⟦static ⟧)⟩tosca::Term& †⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩Make(tosca::Context& ctx)†⟨
    If(#def,
      ()->text⟦†⟨If(HasSorts(#csorts?),
          ()->text⟦¶{ return *(new (ctx) †⟨ParamFormCppClassName(#formname, #csortvars?, CFC_CONS)⟩()); }⟧,
          ()->text⟦¶{ return †⟨ParamFormCppClassName(#formname, #csortvars?, CFC_CONS)⟩::SINGLETON; }⟧)⟩⟧,
      ()->text⟦;⟧)⟩⟧

/* Generate Use constructor corresponding to the given `#sortname`. */
func CppVarConstructorUse(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #def:Bool) -> Text4_text_sort
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
†⟨CppFormQualifier(#sortname, #csortvars?, CFC_VARUSE, #def)⟩†⟨FormCppClassName(#sortname)⟩Use(†⟨ParamFormCppClassName(#sortname, #csortvars?, CFC_VAR)⟩& v)†⟨
   If(#def,
     ()->text⟦: tosca::VariableUse::VariableUse(v) {}⟧,
     ()->text⟦;⟧)⟩⟧

/* Generate base method GetVariable corresponding to the given `#sortname`. */
func CppMethodGetVariable(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #def:Bool) -> Text4_text_sort
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
†⟨TextIf(Not(#def), ()->text⟦virtual ⟧)⟩Optional<†⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩†⟨ParamFormCppClassName(#sortname, (), CFC_VAR)⟩> †⟨CppQualifier(#sortname, #csortvars?, #def)⟩GetVariable() const†⟨
   If(#def,
     ()->text⟦¶{→
return Optional<†⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩†⟨ParamFormCppClassName(#sortname, (), CFC_VAR)⟩>::nullopt;←
}⟧, ()->text⟦;⟧)⟩⟧

/* Generate static method MakeVariable corresponding to the given `#sortname`. */
func CppMethodMakeVariable(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #allowvar: Bool, #def: Bool) -> Text4_text_sort
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
†⟨TextIf(Not(#def), ()->text⟦static ⟧)⟩tosca::Variable& †⟨CppQualifier(#sortname, #csortvars?, #def)⟩MakeVariable(tosca::Context ctx, const std::string& hint)†⟨
   If(#def,
     ()->If(#allowvar,
       ()->text⟦¶{→
return *(new (ctx) †⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩†⟨ParamFormCppClassName(#sortname, (), CFC_VAR)⟩(ctx.MakeGlobalName(hint)));←
}⟧,    ()->text⟦¶{ return Term::MakeVariable(ctx, hint); }⟧),
     ()->text⟦;⟧)⟩⟧

/* Generate static method MakeTerm corresponding to the given `#sortname`. */
func CppMethodMakeTerm(#sortname: String, #csortvars?: List<Core_csortvars_sort>, #cform*: List<Core_cform_sort>, #def: Bool) -> Text4_text_sort
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
†⟨TextIf(Not(#def), ()->text⟦static ⟧)⟩tosca::Term& †⟨CppQualifier(#sortname, #csortvars?, #def)⟩MakeTerm(tosca::Context& ctx, const std::string& symbol)†⟨
  If(#def,
    ()->text⟦¶{→†⟨TextMapFoldES((cform)->CppMakeForm(#csortvars?, cform), #cform*)⟩
throw std::invalid_argument(symbol);←¶}⟧,
    ()->text⟦;⟧)⟩⟧

func CppMakeForm(List<Core_csortvars_sort>, Core_cform_sort) -> Text4_text_sort

  rule CppMakeForm(#csortvars?, cform⟦ ##CONSTRUCTOR ##csortsdefault? ⟧)
  → text⟦¶if (symbol == †⟨Text-QuoteEscape(#CONSTRUCTOR)⟩)→
return †⟨ParamFormCppClassName(#CONSTRUCTOR, #csortvars?, CFC_CONS)⟩::Make(ctx);←⟧

    rule CppMakeForm(#csortvars?, #cform)
    → text⟦⟧

/* Generate method GetVariable corresponding to the given `#sortname`. */
func CppVarMethodGetVariable(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #def:Bool) -> Text4_text_sort
→ text⟦
   †⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
   Optional<†⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩†⟨ParamFormCppClassName(#sortname, (), CFC_VAR)⟩> †⟨CppFormQualifier(#sortname, #csortvars?, CFC_VARUSE, #def)⟩GetVariable() const†⟨
   If(#def,
     ()->text⟦{
         return make_optional<†⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩†⟨ParamFormCppClassName(#sortname, (), CFC_VAR)⟩>(dynamic_cast<†⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩†⟨ParamFormCppClassName(#sortname, (), CFC_VAR)⟩&>(VariableUse::GetGVariable().value()));
       }⟧,
     ()->text⟦;⟧)⟩⟧

/* Generate method GetGVariable corresponding to the given `#sortname`. Needed to resolve multiple inheritance ambiguity. */
func CppVarMethodGetGVariable(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #def:Bool) -> Text4_text_sort
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
   Optional<tosca::Variable> †⟨CppFormQualifier(#sortname, #csortvars?, CFC_VARUSE, #def)⟩GetGVariable() const†⟨
   If(#def,
     ()->text⟦ { return VariableUse::GetGVariable(); }⟧,
     ()->text⟦;⟧)⟩⟧

/* Generate the variable class constructor for the given `#sortname`. */
func CppVarConstructorVar(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #def:Bool) -> Text4_text_sort
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
   †⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩†⟨ParamFormCppClassName(#sortname, (), CFC_VAR)⟩(std::string name)†⟨
   If(#def,
     ()->text⟦: tosca::Variable(std::move(name)) {}⟧,
     ()->text⟦;⟧)⟩⟧

/* Generate the Symbol method for the given `#formname`. */
func CppFormMethodSymbol(#sortname: String, #csortvars?: List<Core_csortvars_sort>, #formname:String, #def:Bool) -> Text4_text_sort
rule CppFormMethodSymbol(#sortname, #csortvars?, #formname, #def)
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
†⟨TextIf(Not(#def), ()->text⟦virtual ⟧)⟩const std::string& †⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩Symbol() const†⟨
  If(#def, ()->text⟦
{→
static const std::string symbol(†⟨Text-QuoteEscape(#formname)⟩);
return symbol;←
}⟧, ()->text⟦;⟧)⟩⟧

/* Generate the Symbol method for the given `#sortname`. */
func CppVarMethodSymbol(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #def:Bool) -> Text4_text_sort
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
†⟨TextIf(Not(#def), ()->text⟦virtual ⟧)⟩const std::string& †⟨CppFormQualifier(#sortname, #csortvars?, CFC_VARUSE, #def)⟩Symbol() const†⟨
  If(#def, ()->text⟦ { return VariableUse::Symbol(); }⟧, ()->text⟦;⟧)⟩⟧

/* Generate overridden lookup method (the 'as' method) for the given `formname`. */
func CppFormMethodAs(String, List<Core_csortvars_sort>, String, Bool) -> Text4_text_sort
rule CppFormMethodAs(#sortname, #csortvars?, #formname, #def)
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
Optional<†⟨ParamFormCppClassName(#formname, #csortvars?, CFC_CONS)⟩> †⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩†⟨CppAsMethodName(#formname)⟩(tosca::Context& ctx)†⟨
  If(#def, ()->text⟦
{→
return make_optional<†⟨ParamFormCppClassName(#formname, #csortvars?, CFC_CONS)⟩>(*this);←
}⟧, ()->text⟦;⟧)⟩⟧

/* Generate overridden Copy method for the given form.*/
func CppFormMethodCopy(String, List<Core_csortvars_sort>, String, Bool) -> Text4_text_sort
rule CppFormMethodCopy(#sortname, #csortvars?, #formname, #def)
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
tosca::Term& †⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩Copy(tosca::Context& ctx)†⟨
  If(#def, ()->text⟦¶{ return Make(ctx); }⟧, ()->text⟦;⟧)⟩⟧

/* Generate overridden variable Copy method for the given `#sortname`.  */
func CppVarMethodCopy(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #def:Bool) -> Text4_text_sort
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
tosca::Variable& †⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩Copy(tosca::Context& ctx) const†⟨
  If(#def, ()->text⟦¶{ return †⟨CppFnName(ConcatString("var", #sortname))⟩(ctx, Symbol()); }⟧, ()->text⟦;⟧)⟩⟧

/* Generate getValue method for the given `formname`. */
func CppFormGetValue(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #formname:String, #csorts?: List<Core_csorts_sort>, #def: Bool) -> Text4_text_sort
→ MaybeCppClassFields(#csorts?, (isvar type index subindex)->
     CppGetValue(isvar, type, index, subindex, #def, TextIf(#def, ()->text⟦†⟨CppTemplatePrefix(#csortvars?)⟩¶⟧), CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)))

/* Generate GetValueXX for each form parameters */
func CppGetValue(Bool, Text4_text_sort, Numeric, Numeric, Bool, Text4_text_sort, Text4_text_sort) -> Text4_text_sort

  rule CppGetValue(FALSE, #type, #index, #subindex, #def, #prefix, #qualifier)
  → text⟦†⟨#prefix⟩†⟨#type⟩& †⟨#qualifier⟩getValue†⟨NumberToText(#index)⟩(tosca::Context& ctx, bool mustforce)†⟨
      If(#def, ()->text⟦
{→
return *†⟨FieldName(#index)⟩;←
}⟧, ()->text⟦;⟧)⟩⟧

  rule CppGetValue(TRUE, #type, #index, #subindex, #def, #prefix, #qualifier)
  → text⟦†⟨#prefix⟩†⟨#type⟩& †⟨#qualifier⟩getVar†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩()†⟨
      If(#def, ()->text⟦
{→
return *†⟨VarFieldName(#index, #subindex)⟩;←
}⟧, ()->text⟦;⟧)⟩⟧

/* Generate the generic Sub function for the given `#form` */
func CppFormGetSub(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #formname:String, #csorts?: List<Core_csorts_sort>, #def: Bool) -> Text4_text_sort
→ TextIf(Not(IsEmpty(MaybeSortsToSorts(#csorts?))), ()->text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
Optional<tosca::Term> †⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩Sub(int subi) const†⟨
    If(#def, ()->text⟦
{→
switch (subi)
{→†⟨MaybeCppClassFields(#csorts?, (isvar type index subindex)->CppGetSub(isvar, index))⟩
default: return Optional<tosca::Term>::nullopt;←
}←
}⟧, ()->text⟦;⟧)⟩⟧)

func CppGetSub(Bool, Numeric) -> Text4_text_sort

  rule CppGetSub(FALSE, #index)
  → text⟦¶case ⟨STRING: FormatInteger(Minus(#index, 1))⟩: return make_optional<tosca::Term>(*†⟨FieldName(#index)⟩);⟧

  rule CppGetSub(TRUE, #index) // this is a scoped variable, not a sub. Skip.
  → text⟦⟧

/* Generate the generic SetSub function for the given `#form` */
func CppFormSetSub(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #formname:String, #csorts?: List<Core_csorts_sort>, #def: Bool) -> Text4_text_sort
→ TextIf(Not(IsEmpty(MaybeSortsToSorts(#csorts?))), ()->text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
void †⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩SetSub(int subi, tosca::Term& sub)†⟨
     If(#def, ()->text⟦¶{→
assert(sub.refcount > 0);
switch (subi)
{→†⟨MaybeCppClassFields(#csorts?, (isvar type index subindex)->CppSetSub(isvar, type, index))⟩
default: assert(false);←
}←
}⟧, ()->text⟦;⟧)⟩⟧)

func CppSetSub(Bool, Text4_text_sort, Numeric) -> Text4_text_sort

  rule CppSetSub(FALSE, #type, #index)
  → text⟦
case †⟨NumberToText(Minus(#index, 1))⟩:→
if (†⟨FieldName(#index)⟩)→¶†⟨FieldName(#index)⟩->Release();←
†⟨FieldName(#index)⟩ = &dynamic_cast<†⟨#type⟩&>(sub);
break;←⟧

  rule CppSetSub(TRUE, #type, #index) // this is a scoped variable, not a sub. Skip.
  → text⟦⟧

/* Generate the generic Binder function for the given `#form` */
func CppFormGetBinder(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #formname:String, #csorts?: List<Core_csorts_sort>, #def: Bool) -> Text4_text_sort
→ TextIf(HasBindersSorts(MaybeSortsToSorts(#csorts?)), ()->text⟦
     †⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
Optional<tosca::Variable> †⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩Binder(int subi, int binderi) const†⟨
If(#def, ()->text⟦
{→
switch (subi)
{→†⟨CppGetSubBinders(MaybeSortsToSorts(#csorts?), 1)⟩
default: return Optional<tosca::Variable>::nullopt;←
}←
}⟧, ()->text⟦;⟧)⟩⟧)

func CppGetSubBinders(List<Core_csort_sort>, Numeric) -> Text4_text_sort

  rule CppGetSubBinders(csort*⟦⟧, #index)
  → text⟦⟧

  rule CppGetSubBinders(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦†⟨If(HasBindersSort(#csort),
          ()->text⟦
case †⟨NumberToText(Minus(#index, 1))⟩:
{→
switch (binderi)
{→†⟨CppClassField(CppTypes(#csort), #index, 1, (isvar type index subindex)->CppGetBinder(isvar, index, subindex))⟩
default: return Optional<Variable>::nullopt;←
}←
}⟧,
           ()->text⟦⟧)⟩
      †⟨CppGetSubBinders(#csort*, Plus(#index, 1))⟩⟧

func CppGetBinder(Bool, Numeric, Numeric) -> Text4_text_sort

  rule CppGetBinder(FALSE, #index, #subindex)
  → text⟦⟧

  rule CppGetBinder(TRUE, #index, #subindex)
  → text⟦¶case †⟨NumberToText(Minus(#subindex, 1))⟩: return *†⟨VarFieldName(#index, #subindex)⟩;⟧

  /* Generate the generic SetBinder function for the given `#form` */
  func CppFormSetBinder(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #formname:String, #csorts?: List<Core_csorts_sort>, #def: Bool) -> Text4_text_sort
  → TextIf(HasBindersSorts(MaybeSortsToSorts(#csorts?)), ()->text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
void †⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩SetBinder(int i, int j, tosca::Variable& var)†⟨
      If(#def, ()->text⟦
{→
switch (i)
{→†⟨CppSetSubBinders(MaybeSortsToSorts(#csorts?), 1)⟩
default: assert(false);←
}←
}⟧, ()->text⟦;⟧)⟩⟧)

  func CppSetSubBinders(List<Core_csort_sort>, Numeric) -> Text4_text_sort

    rule CppSetSubBinders(csort*⟦⟧, #index)
    → text⟦⟧

    rule CppSetSubBinders(csort*⟦ ##csort ##csort* ⟧, #index)
    → text⟦†⟨If(HasBindersSort(#csort),
            ()->text⟦
case †⟨NumberToText(Minus(#index, 1))⟩:
{→
switch (j)
{→†⟨CppClassField(CppTypes(#csort), #index, 1, (isvar type index subindex)->CppSetBinder(isvar, type, index, subindex))⟩
default: assert(false);←
}
break;←
}⟧,
             ()->text⟦⟧)⟩†⟨CppSetSubBinders(#csort*, Plus(#index, 1))⟩⟧

  func CppSetBinder(Bool, Text4_text_sort, Numeric, Numeric) -> Text4_text_sort

    rule CppSetBinder(FALSE, #type, #index, #subindex)
    → text⟦⟧

    rule CppSetBinder(TRUE, #type, #index, #subindex)
    → text⟦
case †⟨NumberToText(Minus(#subindex, 1))⟩:→
if (†⟨VarFieldName(#index, #subindex)⟩) †⟨VarFieldName(#index, #subindex)⟩->Release();
†⟨VarFieldName(#index, #subindex)⟩ = &dynamic_cast<†⟨#type⟩&>(var);
break;←⟧

/* Generate the MakeFree method for the given `#formname` */
func CppFormMakeFree(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #formname:String, #csorts?: List<Core_csorts_sort>, #def: Bool) -> Text4_text_sort
→ TextIf(Not(IsEmpty(MaybeSortsToSorts(#csorts?))), ()->text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
tosca::Variable& †⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩MakeFree(tosca::Context& ctx, int subi, const std::string& hint)†⟨
If(#def, ()->text⟦¶{→
switch (subi)
{→†⟨MaybeCppClassFields(#csorts?, (isvar type index subindex)->CppMakeFreeVariable(isvar, type, index))⟩
default: assert(false);←
}←
}⟧, ()->text⟦;⟧)⟩⟧)

/* Generate the MakeBound method for the given `#formname` */
func CppFormMakeBound(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #formname:String, #csorts?: List<Core_csorts_sort>, #def: Bool) -> Text4_text_sort
→ TextIf(Not(IsEmpty(MaybeSortsToSorts(#csorts?))), ()->text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
tosca::Variable& †⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩MakeBound(tosca::Context& ctx, int subi, int binderi, const std::string& hint)†⟨
If(#def, ()->text⟦¶{→
switch (subi)
{→†⟨CppMakeBoundBinders(MaybeSortsToSorts(#csorts?), 1)⟩
default: assert(false);←
}←
}⟧, ()->text⟦;⟧)⟩⟧)

func CppMakeBoundBinders(List<Core_csort_sort>, Numeric) -> Text4_text_sort

  rule CppMakeBoundBinders(csort*⟦⟧, #index)
  → text⟦⟧

  rule CppMakeBoundBinders(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦†⟨If(HasBindersSort(#csort),
          ()->text⟦
case †⟨NumberToText(Minus(#index, 1))⟩:
{→
switch (binderi)
{→†⟨CppClassField(CppTypes(#csort), #index, 1, (isvar type index subindex)->CppMakeBoundVariable(isvar, type, subindex))⟩
default: assert(false);←
}
break;←
}⟧,
           ()->text⟦⟧)⟩†⟨CppMakeBoundBinders(#csort*, Plus(#index, 1))⟩⟧


func CppMakeFreeVariable(Bool, Text4_text_sort, Numeric) -> Text4_text_sort
rule CppMakeFreeVariable(TRUE, #type, #index)  → text⟦⟧
rule CppMakeFreeVariable(FALSE, #type, #index) → text⟦¶case †⟨NumberToText(Minus(#index, 1))⟩: return †⟨#type⟩::MakeVariable(ctx, ctx.MakeGlobalName(hint));⟧

func CppMakeBoundVariable(Bool, Text4_text_sort, Numeric) -> Text4_text_sort
rule CppMakeBoundVariable(FALSE, #type, #index)  → text⟦⟧
rule CppMakeBoundVariable(TRUE, #type, #index) → text⟦¶case †⟨NumberToText(Minus(#index, 1))⟩: return *(new (ctx) †⟨#type⟩::†⟨#type⟩(ctx.MakeGlobalName(hint)));⟧


/* Generate the MakeTerm method for the given `#formname` */
func CppFormMakeTerm(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #formname:String, #csorts?: List<Core_csorts_sort>, #def: Bool) -> Text4_text_sort
→ TextIf(Not(IsEmpty(MaybeSortsToSorts(#csorts?))), ()->text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
tosca::Term& †⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩MakeSubTerm(tosca::Context& ctx, int subi, const std::string& symbol)†⟨
If(#def, ()->text⟦¶{→
switch (subi)
{→†⟨MaybeCppClassFields(#csorts?, (isvar type index subindex)->CppMakeTerm(isvar, type, index))⟩
default: assert(false);←
}←
}⟧, ()->text⟦;⟧)⟩⟧)


func CppMakeTerm(Bool, Text4_text_sort, Numeric) -> Text4_text_sort
rule CppMakeTerm(TRUE, #type, #index)  → text⟦⟧
rule CppMakeTerm(FALSE, #type, #index) → text⟦¶case †⟨NumberToText(Minus(#index, 1))⟩: return †⟨#type⟩::MakeTerm(ctx, symbol);⟧

/* Generate the SINGLETON static field method for the given `#formname`. Only if the form is constant */
func CppFormSingleton(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #formname:String, #csorts?: List<Core_csorts_sort>, #def: Bool) -> Text4_text_sort
→ if HasSorts(#csorts?)
    text⟦⟧
  else
    text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
†⟨TextIf(Not(#def), ()->text⟦static ⟧)⟩†⟨ParamFormCppClassName(#formname, #csortvars?, CFC_CONS)⟩& †⟨TextIf(#def, ()->text⟦†⟨ParamFormCppClassName(#formname, #csortvars?, CFC_CONS)⟩::⟧)⟩SINGLETON†⟨
      If(#def,
        ()->text⟦ = *(::new †⟨ParamFormCppClassName(#formname, #csortvars?, CFC_CONS)⟩());⟧,
        ()->text⟦;⟧)⟩⟧


// --- Generate code for class field declarations, initialization, lookup, and update.

/* Generic form sorts traversal */
func MaybeCppClassFields(List<Core_csorts_sort>, (Bool Text4_text_sort Numeric Numeric)->Text4_text_sort) -> Text4_text_sort

  rule MaybeCppClassFields(csorts?⟦⟧, #print)
  → text⟦⟧

  rule MaybeCppClassFields(csorts?⟦ ( ##csort* ) ⟧, #print)
  → CppClassFields(#csort*, 1, #print)

func CppClassFields(List<Core_csort_sort>, Numeric, (Bool Text4_text_sort Numeric Numeric)->Text4_text_sort) -> Text4_text_sort

  rule CppClassFields(csort*⟦⟧, #index, #print)
  → text⟦⟧

  rule CppClassFields(csort*⟦ ##csort ##csort* ⟧, #index, #print)
  → text⟦†⟨CppClassField(CppTypes(#csort), #index, 1, #print)⟩†⟨CppClassFields(#csort*, Plus(#index, 1), #print)⟩⟧

func CppClassField(List<Text4_text_sort>, Numeric, Numeric, (Bool Text4_text_sort Numeric Numeric)->Text4_text_sort) -> Text4_text_sort

  rule CppClassField((#type,), #index, #subindex, #print)
  → #print(FALSE, #type, #index, #subindex)

  rule CppClassField((#type, #types...), #index, #subindex, #print)
  → text⟦†⟨#print(TRUE, #type, #index, #subindex)⟩†⟨CppClassField(#types, #index, Plus(#subindex, 1), #print)⟩⟧

func FieldName(#index: Numeric) -> Text4_text_sort
→ text⟦field†⟨NumberToText(#index)⟩⟧

func VarFieldName(#index: Numeric, #subindex: Numeric) -> Text4_text_sort
→ text⟦field†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩⟧

/* Print separator when not first field */
func FieldSep(#sep: Text4_text_sort, #index: Numeric, #subindex: Numeric) -> Text4_text_sort
→ TextIf(Not(And(NumberEqual(#index, 1), NumberEqual(#subindex, 1))), ()->#sep)

/* Field initialization helper */
func CppInitField(Bool, Text4_text_sort, Numeric, Numeric) -> Text4_text_sort
rule CppInitField(FALSE, #type, #index, #subindex) → text⟦†⟨FieldSep(text⟦, ⟧, #index, #subindex)⟩†⟨FieldName(#index)⟩(&†⟨ParamName(#index)⟩)⟧
rule CppInitField(TRUE, #type, #index, #subindex)  → text⟦†⟨FieldSep(text⟦, ⟧, #index, #subindex)⟩†⟨VarFieldName(#index, #subindex)⟩(&†⟨VarParamName(#index, #subindex)⟩)⟧

/* Field release helper */
func CppReleaseField(Bool, Text4_text_sort, Numeric, Numeric) -> Text4_text_sort
rule CppReleaseField(FALSE, #type, #index, #subindex) → text⟦¶†⟨FieldName(#index)⟩->Release();⟧
rule CppReleaseField(TRUE, #type, #index, #subindex)  → text⟦¶†⟨VarFieldName(#index, #subindex)⟩->Release();⟧

/* Field nullification  helper */
func CppNullifyField(Bool, Text4_text_sort, Numeric, Numeric) -> Text4_text_sort
rule CppNullifyField(FALSE, #type, #index, #subindex) → text⟦†⟨FieldSep(text⟦, ⟧, #index, #subindex)⟩†⟨FieldName(#index)⟩(0)⟧
rule CppNullifyField(TRUE, #type, #index, #subindex)  → text⟦†⟨FieldSep(text⟦, ⟧, #index, #subindex)⟩†⟨VarFieldName(#index, #subindex)⟩(0)⟧

// --- Function translation functions

func CppFunctionDecl(#env: {String : EnvEntry}, #key: String, #header: Bool) -> Text4_text_sort
→ CppFunctionDeclD(#env, UnSOME(GetFuncSort(GetContent(#env), #key)), #header, FALSE)

func CppFunctionDeclD({String : EnvEntry}, Core_cdecl_sort, Bool, Bool) -> Text4_text_sort
rule CppFunctionDeclD(#env, cdecl⟦ ##canno* ##EXTERN? func ##csortvars? ##csort ##CONSTRUCTOR ##csortsdefault? ⟧, #header, #forward)
→ TextIf(And(Not(HasAnnotation("Extern", #canno*)), Or(#forward, Or(And(#header, Not(IsEmpty(#csortvars?))), And(Not(#header), IsEmpty(#csortvars?))))), ()->
  text⟦¶¶†⟨CppTemplatePrefix(#csortvars?)⟩
†⟨CppTypeRef(#csort)⟩ †⟨CppFnName(#CONSTRUCTOR)⟩(tosca::Context& ctx†⟨CppMaybeFunctionParams(SetContext(SetFnAnno(#env, #canno*), text⟦ctx⟧, 1), #csortsdefault?, (env) ->
      CppMaybeBody(env, #CONSTRUCTOR, GenBody(#csortvars?, #header, #forward)))⟩⟧) // missing )

func CppMaybeFunctionParams({String : EnvEntry}, List<Core_csortsdefault_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort
   rule CppMaybeFunctionParams(#env, csortsdefault?⟦⟧, #cont)
   → #cont(#env)

   rule CppMaybeFunctionParams(#env, csortsdefault?⟦ ( ##csortdefault* ) ⟧, #cont)
   → CppFunctionParams(NewParams(#env), #csortdefault*, #cont)

/* Generate method signature and record the argument names in the environment, keeping them in order */
func CppFunctionParams({String : EnvEntry}, List<Core_csortdefault_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppFunctionParams(#env, csortdefault*⟦ ⟧, #cont)
   → #cont(#env)

  rule CppFunctionParams(#env, csortdefault*⟦ ##csort ##csortdefault* ⟧, #cont) // no default value: has been expanded
  → CppFunctionParam(#env, CppTypes(#csort), #csort, (env) -> CppFunctionParams(env, #csortdefault*, #cont))

func CppFunctionParam({String : EnvEntry}, List<Text4_text_sort>, Core_csort_sort, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  // Monomorphic sort
  rule CppFunctionParam(#env, (#type,), csort⟦ ##canno* ##CONSTRUCTOR ##csorts? ⟧, #cont)
  → text⟦, †⟨#type⟩& ⟨STRING: value:String⟩†⟨#cont(AddParam(#env, text⟦⟨STRING: value⟩⟧, csort⟦ ##canno* ##CONSTRUCTOR ##csorts? ⟧))⟩⟧

  // Sort variable
  rule CppFunctionParam(#env, (#type,), csort⟦ ##canno*  ##VARIABLE ⟧, #cont)
  → text⟦, †⟨#type⟩& ⟨STRING: value:String⟩†⟨#cont(AddParam(#env, text⟦⟨STRING: value⟩⟧, csort⟦ ##canno* ##VARIABLE ⟧))⟩⟧

  // Syntactic variable sort
 rule CppFunctionParam(#env, (#type, #types...), csort⟦ [ ##csort ] ##csort2 ⟧, #cont)
 → text⟦, †⟨#type⟩& ⟨STRING: var:String⟩†⟨
     CppFunctionParam(AddParam(#env, text⟦⟨STRING: var⟩⟧, #csort), #types, #csort2, #cont)⟩⟧

 // Formal parameter sort
 rule CppFunctionParam(#env, #types, csort⟦ ##canno* ( ##csort ) ##csort2 ⟧, #cont)
 → CppFunctionParam(#env, #types, #csort2, #cont)

 rule CppFunctionParam(#env, (#type, ), csort⟦ ##canno* { ##cmapsort* } ⟧, #cont)
 → text⟦, †⟨#type⟩& ⟨STRING: map:String⟩†⟨
     #cont(AddParam(#env, text⟦⟨STRING: map⟩⟧, csort⟦ ##canno* { ##cmapsort* } ⟧))⟩⟧

 rule CppFunctionParam(#env, #types, csort⟦ ##canno* data ##csort ⟧, #cont)
 → CppFunctionParam(#env, #types, #csort, #cont)

 rule CppFunctionParam(#env, #types, csort⟦ ##canno* thunk ##csort ⟧, #cont)
 → CppFunctionParam(#env, #types, #csort, #cont)

/* Generate function body. See GenBody for the exact condition. */
func CppMaybeBody({String : EnvEntry}, String, Bool /* generate body? */) -> Text4_text_sort
rule CppMaybeBody(#env, #key, FALSE) → text⟦);⟧
rule CppMaybeBody(#env, #key, TRUE)  → text⟦) †⟨CppBody(#env, GetRulesForKeyC(GetContent(#env), #key))⟩⟧

func CppBody({String : EnvEntry}, Option<List<Core_cdecl_sort>>) -> Text4_text_sort

  // No rules: it must be an external function (not yet checked but should)
  rule CppBody(#env, NONE)
  → text⟦;⟧

  // At least one rule: not external
  rule CppBody(#env, SOME(#rules))
  → text⟦
{→†⟨TextMapFoldES((rule) -> CppBodyRule(SetDiscard(NewMetas(NewVars(#env)), ()), rule), #rules)⟩†⟨TextIf(Not(HasAnnotation("Fallback", GetFnAnno(#env))), ()->text⟦¶throw std::runtime_error("Missing case");⟧)⟩←¶}⟧

// --- Start method body

func CppBodyRule({String : EnvEntry}, Core_cdecl_sort) -> Text4_text_sort

  rule CppBodyRule(#env, cdecl⟦ ##canno* rule  ##canno*2 ##CONSTRUCTOR ( ##cterm* ) ##csortanno? → ##cterm ⟧)
  → CppPattern(SetRuleAnno(#env, #canno*), #cterm*, #cterm)

  rule CppBodyRule(#env, cdecl⟦ ##canno* rule  ##canno*2 ##CONSTRUCTOR → ##cterm ⟧)
  → CppContractum(SetRuleAnno(#env, #canno*), #cterm)

// --- Pattern matching

func CppPattern(#env: {String : EnvEntry}, #cterms: List<Core_cterm_sort>, #contractum: Core_cterm_sort) -> Text4_text_sort
→ CppCasePattern(SetDelayEntries(#env, {}), #cterms, #contractum)

// Iterate over top-level pattern arguments
func CppCasePattern({String : EnvEntry}, List<Core_cterm_sort>, Core_cterm_sort) -> Text4_text_sort

  rule CppCasePattern(#env, cterm*⟦⟧, #contractum)
  → CppContractum(#env, #contractum)

  rule CppCasePattern(#env, cterm*⟦ ##cterm ##cterm* ⟧, #contractum)
  → let #currentParam = CurrentParam(#env)
    let #currentSort = CurrentParamSort(#env)
    let #nenv = NextParam(CppMayDiscard(#env, #cterm, GetRuleAnno(#env)))
    CppPatternTerm(#nenv, #cterm, #currentParam, SOME(#currentSort), PARAMETER, (env) ->
    CppCasePattern(env, #cterm*, #contractum))

// --- Term pattern matching

func CppPatternTerm({String : EnvEntry}, Core_cterm_sort, Text4_text_sort /* Current term */,
                       Option<Core_csort_sort> /* Sort when known */, Storage, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternTerm(#env, cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #term, #csort, #storage, #cont)
  → text⟦¶auto ⟨STRING: value:String⟩ = †⟨#term⟩.†⟨CppAsMethodName(#CONSTRUCTOR)⟩(†⟨GetContext(#env)⟩);
if (⟨STRING: value⟩)
{→†⟨CppPatternMaybeSubs(#env, #cterms?, text⟦⟨STRING: value⟩⟧, MaybeFindFormC(GetContent(#env), #csort, #CONSTRUCTOR), #cont)⟩←¶}⟧

  // TODO: check literal
  rule CppPatternTerm(#env, cterm⟦ ##canno* ##cliteral ⟧, #term, #csort, #storage, #cont)
  → #cont(#env)

  // REVISIT: bound variable reordering, ie. (x)(y)#(y, x)
  // For now only accepts patterns of the form (x)...(y)#(x, ... y)
  rule CppPatternTerm(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #term, #csort, #storage, #cont)
  → CppPatternMaybeMetaArgs(#env, #METAVAR, #csubst?, #term, #csort, #storage, #cont)

  rule CppPatternTerm(#env, cterm⟦ ##canno* ##VARIABLE  ##csortanno? ⟧, #term, #csort, #storage, #cont)
  → CppPatternVariable(MaybeGetVar(#env, #VARIABLE), #env, #VARIABLE, MaybeSortAnnoToSort(#csortanno?), #term, #cont)

  rule CppPatternTerm(#env, cterm⟦ ##canno* { ##cmapentries? } : { ##cmapsort } ⟧, #term, #csort, #storage, #cont)
  → CppPatternMap(#env, #cmapentries?, #term, #cmapsort, #cont)

  rule CppPatternTerm(#env, cterm⟦ ##canno* [ v ##csortanno? ] ##cterm[v] ⟧, #term, #csort, PARAMETER, #cont)
  → let #currentParam = CurrentParam(#env)
    let #nextParam = NextParam(AddVar(CppMayDiscard(#env, #cterm[var:String], GetRuleAnno(#env)), var, Bound(#term, MaybeSortAnnoToSort(#csortanno?))))
    CppPatternTerm(#nextParam, #cterm[var], #currentParam, SOME(CurrentParamSort(#env)), PARAMETER, #cont)

  rule CppPatternTerm(#env, cterm⟦ ##canno* [ v : ##csort ] ##cterm[v] ⟧, #term, #sort, ARGUMENT, #cont)
  → text⟦_C†⟨CppType(#csort)⟩Var& ⟨STRING: boundvar:String⟩ = †⟨GetParent(#env)⟩.value().getVar†⟨NumberToText(GetSubIndex(#env))⟩_†⟨NumberToText(GetSubBinderIndex(#env))⟩();†⟨
      CppPatternTerm(IncSubBinderIndex(AddVar(#env, var, Bound(text⟦⟨STRING: boundvar⟩⟧, SOME(#csort)))), #cterm[var], #term, #sort, ARGUMENT, #cont)⟩⟧

  rule CppPatternTerm(#env, cterm⟦ ##canno* ( f  ##csortanno? ) ##cterm[f] ⟧, #term, #csort, #storage, #cont)
  → CppPatternTerm(#env, #cterm[var:String], #term, #csort, #storage, #cont)

  rule CppPatternTerm(#env, cterm⟦ ##canno* ##METAVAR ##csortanno? = ##cterm ⟧, #term, #csort, #storage, #cont)
  → CppPatternNamedTerm(#env, #METAVAR, #cterm, #term, #csort, #storage, #cont)

  rule CppPatternTerm(#env, cterm⟦ ##canno* thunk ##cterm ⟧, #term, #csort, #storage, #cont)
  → Error("Internal Error: invalid thunk in pattern.")

// Pattern matching on construction arguments.
func CppPatternMaybeSubs( {String : EnvEntry}, List<Core_cterms_sort>, Text4_text_sort, Option<PPair<Core_cdecl_sort Core_cform_sort>>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternMaybeSubs(#env, cterms?⟦⟧, #term, #cform, #cont)
  → #cont(#env)

  rule CppPatternMaybeSubs(#env, cterms?⟦()⟧, #term, #cform, #cont)
  → #cont(#env)

  rule CppPatternMaybeSubs(#env, cterms?⟦ ( ##cterm* ) ⟧, #term, SOME(PairCons(#cdecl, cform⟦ ##CONSTRUCTOR ##csortsdefault? ⟧)), #cont)
  → CppPatternSubs(#env, #cterm*, #term, 1, SOME(MaybeSortsDefaultToSorts(#csortsdefault?)), #cont)

  rule CppPatternMaybeSubs(#env, cterms?⟦ ( ##cterm* ) ⟧, #term, NONE, #cont)
  → CppPatternSubs(#env, #cterm*, #term, 1, NONE, #cont)

  func CppPatternSubs( {String : EnvEntry}, List<Core_cterm_sort>,
                     Text4_text_sort /* parent term */, Numeric /* Current subindex */, Option<List<Core_csort_sort>>, /* sub sorts, if known */
                     ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternSubs(#env, cterm*⟦⟧,  #term, #index, #csort*, #cont)
  → #cont(#env)

  rule CppPatternSubs(#env, cterm*⟦ ##cterm ##cterm* ⟧, #term, #index, #csort*, #cont)
  → let #subsort = SubSort(#env, #cterm, #csort*)
    let #ctx = GetContext(#env)
    let #nenv = SetSubBinderIndex(SetParent(SetSubIndex(#env, #index), #term), 1)
    text⟦¶auto& ⟨STRING: sub:String⟩ = †⟨#term⟩.value().getValue†⟨NumberToText(#index)⟩(†⟨#ctx⟩, true);†⟨
      CppPatternTerm(#nenv, #cterm, text⟦⟨STRING: sub⟩⟧, #subsort, ARGUMENT,
                     (env) -> CppPatternSubs(env, #cterm*, #term, NumberPlus(#index, 1), Maybe((csort)->Tail(csort), #csort*), #cont))⟩⟧

  // --- Variable pattern matching outside of meta

func CppPatternVariable(Option<VarEntry>, {String : EnvEntry}, String, Option<Core_csort_sort>, Text4_text_sort /* Current term */, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  // First variable occurrence: the term is a free variable.
  rule CppPatternVariable(NONE, #env, #variable, #csort, #term, #cont)
  → text⟦¶Optional<_C†⟨MaybeCppTypeD(#csort, text⟦⟧)⟩Var> ⟨STRING: ovar⟩ = †⟨#term⟩.GetVariable();
if (⟨STRING: ovar⟩)
{→
_C†⟨MaybeCppTypeD(#csort, text⟦⟧)⟩Var& ⟨STRING: var⟩ = ⟨STRING: ovar⟩.value();
†⟨CppApplyDelayEntries(AddVar(#env, #variable, Free(text⟦⟨STRING: var⟩⟧, #csort)), #variable, #cont)⟩←¶}⟧

  rule CppPatternVariable(SOME(Bound(#var, #sort)), #env, #variable, #csort, #term, #cont)
  → text⟦¶Optional<_C†⟨MaybeCppTypeD(#csort, text⟦⟧)⟩Var> ⟨STRING: ovar⟩ = †⟨#term⟩.GetVariable();
if (⟨STRING: ovar⟩ && †⟨#var⟩ == ⟨STRING: ovar⟩.value())
{→†⟨#cont(#env)⟩←¶}⟧

  // --- pattern matching inside meta

// Iterate over meta arguments and find corresponding bound variables, and update environment
func CppPatternMaybeMetaArgs({String : EnvEntry}, String, List<Core_csubst_sort>, Text4_text_sort /* Current term */, Option<Core_csort_sort>,
                             Storage, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternMaybeMetaArgs(#env, #metavar, csubst?⟦⟧, #term, #csort, #storage, #cont)
  → CppApplyDelayEntries(AddMeta(#env, #metavar, #term, (), #storage), #metavar, #cont)

  // meta substitution
  rule CppPatternMaybeMetaArgs(#env, #metavar, csubst?⟦ [ ##cterm* ] ⟧, #term, #csort, #storage, #cont)
  → #cont(AddMeta(#env, #metavar, #term, Map((x) -> CppFindBoundVar(#env, x), #cterm*), #storage))

  func CppFindBoundVar( {String : EnvEntry},Core_cterm_sort) -> Text4_text_sort

  rule CppFindBoundVar(#env, cterm⟦ ##canno* ##VARIABLE ⟧)
  → GetVar(#env, #VARIABLE)

  rule CppFindBoundVar(#env, #cterm)
  → Error(ConcatString("Invalid argument in metavariable: ", PrintTerm("", #cterm)))

  // --- Map pattern matching

func CppPatternMap({String : EnvEntry}, List<Core_cmapentries_sort>, Text4_text_sort, Core_cmapsort_sort, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternMap(#env, cmapentries?⟦⟧, #term, #cmapsort, #cont)
  → text⟦¶if (†⟨#term⟩.isEmpty())¶{→¶†⟨#cont(#env)⟩←¶}⟧

  rule CppPatternMap(#env, cmapentries?⟦ ##cmapentry* ⟧, #term, #cmapsort, #cont)
  → CppPatternMapEntries(#env, #cmapentry*, #term, #cmapsort, #cont)

func CppPatternMapEntries({String : EnvEntry}, List<Core_cmapentry_sort>, Text4_text_sort, Core_cmapsort_sort, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternMapEntries(#env, cmapentry*⟦ ##cmapentry ##cmapentry* ⟧, #term, #cmapsort, #cont)
  → CppPatternMapEntry(#env, #cmapentry, #term, #cmapsort, (env)->CppPatternMapEntries(env, #cmapentry*, #term, #cmapsort, #cont))

  rule CppPatternMapEntries(#env, cmapentry*⟦  ⟧, #term, #cmapsort, #cont)
  → #cont(#env)

func CppPatternMapEntry({String : EnvEntry}, Core_cmapentry_sort, Text4_text_sort, Core_cmapsort_sort, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternMapEntry(#env, cmapentry⟦ : ##METAVAR ⟧, #term, #cmapsort, #cont)
  → #cont(AddMeta(#env, #METAVAR, #term, (), ARGUMENT))

  rule CppPatternMapEntry(#env, cmapentry⟦  ¬ ##METAVAR ⟧, #term, #cmapsort, #cont)
  → IfPresent(GetMetaVarO(#env, #METAVAR),
      (key)->text⟦¶if (!†⟨#term⟩.contains(†⟨key⟩))¶{→†⟨#cont(#env)⟩←¶}⟧,
      ()->#cont(DelayMapEntry(#env, #METAVAR, MapEntry(cmapentry⟦ ¬ ##METAVAR ⟧, #term, #cmapsort))))

  rule CppPatternMapEntry(#env, cmapentry⟦ ##METAVAR : ##cterm ⟧, #term, #cmapsort, #cont)
  → IfPresent(GetMetaVarO(#env, #METAVAR),
      (key)->text⟦¶auto ⟨STRING: mval⟩ = †⟨#term⟩.getValue(†⟨GetContext(#env)⟩, †⟨key⟩).asSOME(†⟨GetContext(#env)⟩);
if (⟨STRING: mval⟩)
{→
†⟨CppType(GetMapValueSort(#cmapsort))⟩& ⟨STRING: value⟩ = ⟨STRING: mval⟩.value().getValue1(ctx, true);
†⟨CppPatternTerm(#env, #cterm, text⟦⟨STRING: value⟩⟧, SOME(GetMapValueSort(#cmapsort)), ARGUMENT, #cont)⟩←
}⟧,
      ()->#cont(DelayMapEntry(#env, #METAVAR, MapEntry(cmapentry⟦ ##METAVAR : ##cterm ⟧, #term, #cmapsort))))

  rule CppPatternMapEntry(#env, cmapentry⟦ ##VARIABLE ⟧, #term, #cmapsort, #cont)
  → IfPresent(GetVarO(#env, #VARIABLE),
      (key)->text⟦¶if (!†⟨#term⟩.containsVar(†⟨UnVarVar(key)⟩.GetVariable()))
{→†⟨#cont(#env)⟩←¶}⟧,
      ()->#cont(DelayMapEntry(#env, #VARIABLE, MapEntry(cmapentry⟦ ##VARIABLE ⟧, #term, #cmapsort))))

  rule CppPatternMapEntry(#env, cmapentry⟦ ¬ ##VARIABLE ⟧, #term, #cmapsort, #cont)
  → IfPresent(GetVarO(#env, #VARIABLE),
      (key)->text⟦¶if (†⟨#term⟩.containsVar(†⟨UnVarVar(key)⟩.GetVariable()))
{→†⟨#cont(#env)⟩←¶}⟧,
      ()->#cont(DelayMapEntry(#env, #VARIABLE, MapEntry(cmapentry⟦ ¬ ##VARIABLE ⟧, #term, #cmapsort))))

  rule CppPatternMapEntry(#env, cmapentry⟦ ##VARIABLE : ##cterm ⟧, #term, #cmapsort, #cont)
  → IfPresent(GetVarO(#env, #VARIABLE),
      (key)->text⟦¶auto ⟨STRING: mval⟩ = †⟨#term⟩.getValue(†⟨GetContext(#env)⟩, †⟨UnVarVar(key)⟩.Use(ctx)).asSOME(†⟨GetContext(#env)⟩);
if (⟨STRING: mval⟩)
{→
†⟨CppType(GetMapValueSort(#cmapsort))⟩& ⟨STRING: value⟩ = ⟨STRING: mval⟩.value().getValue1(ctx, true);
†⟨CppPatternTerm(#env, #cterm, text⟦⟨STRING: value⟩⟧, SOME(GetMapValueSort(#cmapsort)), ARGUMENT, #cont)⟩←
}⟧,
      ()->#cont(DelayMapEntry(#env, #VARIABLE, MapEntry(cmapentry⟦ ##VARIABLE : ##cterm ⟧, #term, #cmapsort))))

  rule CppPatternMapEntry(#env, cmapentry⟦ ##STRING ⟧, #term, #cmapsort, #cont)
  → text⟦¶if (†⟨#term⟩.contains(†⟨CppExprLiteral(#env, cliteral⟦ ##STRING ⟧)⟩))
{→†⟨#cont(#env)⟩←}⟧

  rule CppPatternMapEntry(#env, cmapentry⟦ ¬ ##STRING ⟧, #term, #cmapsort, #cont)
  → text⟦¶if (!†⟨#term⟩.contains(†⟨CppExprLiteral(#env, cliteral⟦ ##STRING ⟧)⟩))
{→†⟨#cont(#env)⟩←}⟧

  rule CppPatternMapEntry(#env, cmapentry⟦ ##STRING  : ##cterm ⟧, #term, #cmapsort, #cont)
 → text⟦¶auto ⟨STRING: mval⟩ = †⟨#term⟩.getValue(†⟨GetContext(#env)⟩, †⟨CppExprLiteral(#env, cliteral⟦ ##STRING ⟧)⟩).asSOME(†⟨GetContext(#env)⟩);
if (⟨STRING: mval⟩)
{→
†⟨CppType(GetMapValueSort(#cmapsort))⟩& ⟨STRING: value⟩ = ⟨STRING: mval⟩.value().getValue1(ctx, true);
†⟨CppPatternTerm(#env, #cterm, text⟦⟨STRING: value⟩⟧, SOME(GetMapValueSort(#cmapsort)), ARGUMENT, #cont)⟩
←}⟧


/* Apply delayed map entries waiting for the given `#var` (meta or not) to be initialized */
func CppApplyDelayEntries(#env: {String : EnvEntry}, #var: String, #cont:({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort
→ CppApplyDelayEntriesAux(#env, GetDelayEntriesForVar(#env, #var), #cont)

func CppApplyDelayEntriesAux({String : EnvEntry}, List<MapEntry>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppApplyDelayEntriesAux(#env, (MapEntry(#cmapentry, #term, #cmapsort), #entries...), #cont)
  → CppPatternMapEntry(#env, #cmapentry, #term, #cmapsort, (env)->CppApplyDelayEntriesAux(env, #entries, #cont))

  rule CppApplyDelayEntriesAux(#env, (), #cont)
  → #cont(#env)

// --- Named term

func CppPatternNamedTerm(#env: {String : EnvEntry}, #metavar: String, #cterm: Core_cterm_sort, #term: Text4_text_sort,
                         #csort: Option<Core_csort_sort>, #storage: Storage, #cont: ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort
→ CppPatternMaybeMetaArgs(#env, #metavar, csubst?⟦⟧, #term, #csort, #storage, (env)->
  CppPatternTerm(env, #cterm, #term, #csort, #storage, #cont))

//  --------- Helper function for pattern matching

/* Get sub sort. Get it from term and if not available on sort */
func SubSort(#env: {String : EnvEntry}, #cterm: Core_cterm_sort, #csorts?: Option<List<Core_csort_sort>>) -> Option<Core_csort_sort>
→ SubSort2(SubSortFromTerm(#env, #cterm), #csorts?)

func SubSort2(Option<Core_csort_sort>, Option<List<Core_csort_sort>>) -> Option<Core_csort_sort>
  rule SubSort2(SOME(#csort:Core_csort_sort), #)       → SOME(#csort)
  rule SubSort2(NONE, NONE)                            → NONE
  rule SubSort2(NONE, SOME(csort*⟦ ##csort ##csort* ⟧)) → SOME(#csort)

func SubSortFromTerm({String : EnvEntry}, Core_cterm_sort) -> Option<Core_csort_sort>

  rule SubSortFromTerm(#env, cterm⟦ ##canno* ##cqconstructor ##csortargs? ##cterms? : ##csort ⟧)
  → SOME(#csort)

  rule SubSortFromTerm(#env, cterm⟦ ##canno* ##STRING ⟧)
  → SOME(csort⟦ String ⟧)

  rule SubSortFromTerm(#env, cterm⟦ ##canno* ##NUMBER ⟧)
  → SOME(csort⟦ Numeric⟧)

  rule SubSortFromTerm(#env, cterm⟦ ##canno* ##VARIABLE ##csortanno? ⟧)
  → SubSortFromVar(MaybeGetVar(#env, #VARIABLE), #VARIABLE)

  rule SubSortFromTerm(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧)
  → MaybeSortAnnoToSort(#csortanno?)

  rule SubSortFromTerm(#env, cterm⟦ ##canno* let ##METAVAR ##csortanno? = ##cterm ##cterm2 ⟧)
  → SubSortFromTerm(#env, #cterm2)

  rule SubSortFromTerm(#env, cterm⟦ ##canno* { ##cmapentries? } ##csortanno? ⟧)
  → MaybeSortAnnoToSort(#csortanno?)

  // TODO: maybe error?
  rule SubSortFromTerm(#env, cterm⟦ ##canno* [ x ##csortanno?[] ] ##cterm[x] ⟧)
  → SubSortFromTerm(#env, #cterm[var:String])

  // TODO: maybe error?
  rule SubSortFromTerm(#env, cterm⟦ ##canno* ( f ##csortanno?[] ) ##cterm[f] ⟧)
  → SubSortFromTerm(#env, #cterm[var:String])

func SubSortFromVar(Option<VarEntry>, String) -> Option<Core_csort_sort>
rule SubSortFromVar(NONE, #var)             → NONE
rule SubSortFromVar(SOME(#varEntry), #var)  → UnVarSort(#varEntry)

// ---- Reference counting

/* Determine whether the current parameter must be kept or not. */
func CppMayDiscard({String : EnvEntry}, Core_cterm_sort, List<Core_canno_sort>) -> {String : EnvEntry}

  rule CppMayDiscard(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #ruleanno*)
  → CppMayDiscardMeta(#env, #METAVAR, IfPresent(GetAnnotation("KeepAll", #ruleanno*), (anno)->GetAnnotationArgs(anno), ()->()))

  rule CppMayDiscard(#env, cterm⟦ ##canno* ##METAVAR ##csortanno? = ##cterm  ⟧, #ruleanno*)
  → CppMayDiscardMeta(#env, #METAVAR, IfPresent(GetAnnotation("KeepAll", #ruleanno*), (anno)->GetAnnotationArgs(anno), ()->()))

  // TODO: check for binder reuse. If not, release!
  rule CppMayDiscard(#env, cterm⟦ ##canno* [ x ##csortanno? ] ##cterm[x] ⟧, #ruleanno*)
  → #env

  rule CppMayDiscard(#env, cterm⟦ ##canno* ( f ##csortanno? ) ##cterm[f] ⟧, #ruleanno*)
  → CppMayDiscard(#env, #cterm[f], #ruleanno*)

  rule CppMayDiscard(#env, #cterm, #ruleanno*)
  → AddDiscard(#env, CurrentParam(#env))

func CppMayDiscardMeta(#env: {String : EnvEntry}, #meta: String, #keep: List<Core_cterm_sort>) -> {String : EnvEntry}
→ If(CppMustKeep(#keep, #meta), ()->#env, ()->AddDiscard(#env, CurrentParam(#env)))

/* Discard term parameters not used in the contraction */
func CppDiscard(#env: {String : EnvEntry}) -> Text4_text_sort
→ TextMapFoldES((param)->text⟦¶†⟨param⟩.Release();⟧, GetDiscard(#env))

// Tell whether the given `#meta` variable must be kept
func CppMustKeep(#keep: List<Core_cterm_sort>, #meta:String) -> Bool
→ HasOption(PickFirst(#keep, (term)->IsNamedMeta(term, #meta)))

/* Keep subterm used in contraction */
func CppKeepSub(#env: {String : EnvEntry}, #canno*: List<Core_canno_sort>) -> Text4_text_sort
→ CppKeepSub2(#env, IfPresent(GetAnnotation("KeepAll", #canno*), (anno)->GetAnnotationArgs(anno), ()->()))

func CppKeepSub2(#env: {String : EnvEntry}, #keep: List<Core_cterm_sort>) -> Text4_text_sort
→ TextMapFoldES((annometa)->
                  If(CgIsArgument(GetMetaStorage(#env, Snd(annometa))),
                    ()->text⟦¶†⟨GetMetaVar(#env, Snd(annometa))⟩.AddRef();⟧,
                    ()->text⟦⟧),
                GetAnnoMetaVariables(#keep))

// ----- Contraction

func CppContractum(#env: {String : EnvEntry}, #term: Core_cterm_sort) -> Text4_text_sort
→ let #keep = CppKeepSub(#env, GetRuleAnno(#env))
  let #discard = CppDiscard(#env)
  let #freshes =  CppFreshesTerm(SetCounter(SetFreshCounter(#env, 0), 0), #term)
  let #contraction = CppStatementTerm(SetCounter(Fst(#freshes), 0), #term)
  text⟦†⟨#keep⟩†⟨#discard⟩†⟨Snd(#freshes)⟩†⟨Snd(#contraction)⟩⟧

/* Generate the contraction code. Two passes are performed:
   - the first pass generates statements initializing fresh and bound variables. Variable names are deterministic using an internal counter
   - the second pass generates statements and expressions. Bound variables names are recomputed in a deterministic manner
    */

// TODO: issue in type inference prevent using type alias
type CppConsumer = ({String : EnvEntry} /* Environment */ Text4_text_sort /* Statement or Expression */)->Text4_text_sort

// ---- Generate term code - Produces C++ statements

func CppStatementTerm({String : EnvEntry}, Core_cterm_sort) -> PPair<{String : EnvEntry} Text4_text_sort  /* Statement */>

rule CppStatementTerm(#env, cterm⟦ ##canno* let ##METAVAR : ##csort = ##cterm ##cterm2 ⟧)
→ let #cppvar = text⟦⟨STRING: Mangle(RemoveFirstChar(#METAVAR))⟩⟧
  let #letexpr = CppExprTerm(SetInline(#env), #cterm)
  let #letbody = CppStatementTerm(AddMeta(First3(#letexpr), #METAVAR, #cppvar, (), ARGUMENT), #cterm2)
  PairCons(Fst(#letbody),
          text⟦†⟨Third3(#letexpr)⟩¶†⟨CppType(#csort)⟩& †⟨#cppvar⟩ = †⟨Second3(#letexpr)⟩;†⟨Snd(#letbody)⟩⟧)

rule CppStatementTerm(#env, #cterm)
→ let #expr = CppExprTerm(SetInline(#env), #cterm)
  PairCons(First3(#expr), text⟦†⟨Third3(#expr)⟩¶return †⟨Second3(#expr)⟩;⟧)

// ---- Generate fresh variable - Only in C++ statement mode

/*func CppFreshesTermCont(#env: {String : EnvEntry}, #term: Core_cterm_sort, #cont: ({String : EnvEntry})->Text4_text_sort) -> Text4_text_sort
→ let #result = CppFreshesTerm(#env, #term)
  text⟦†⟨Snd(#result)⟩†⟨#cont(Fst(#result))⟩⟧*/

func CppFreshesTerm({String : EnvEntry}, Core_cterm_sort) -> PPair<{String : EnvEntry} Text4_text_sort>

  rule CppFreshesTerm(#env, cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧)
  → CppFreshesMaybeTerms(#env, #cterms?)

  rule CppFreshesTerm(#env, cterm⟦ ##canno* ##cliteral ⟧)
  → PairCons(#env, text⟦⟧)

  rule CppFreshesTerm(#env, cterm⟦ ##canno* ##VARIABLE ##csortanno? ⟧)
  → CppFreshesVariable(#env, GetAnnotation("Reuse", #canno*), MaybeGetVar(#env, #VARIABLE), #VARIABLE, #csortanno?, TRUE)

  rule CppFreshesTerm(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧)
  → let #fterms = CppFreshesMaybeTerms(#env, #cterms?)
    let #fsubst = CppFreshesMaybeSubst(Fst(#fterms), #csubst?)
    PairCons(Fst(#fsubst), text⟦†⟨Snd(#fterms)⟩†⟨Snd(#fsubst)⟩⟧)

  rule CppFreshesTerm(#env, cterm⟦ ##canno* [ x ##csortanno? ] ##cterm[x] ⟧)
  → let #fvar = CppFreshesVariable(#env, GetAnnotation("Reuse", #canno*), NONE, var, #csortanno?, FALSE)
    let #fterm = CppFreshesTerm(Fst(#fvar), #cterm[var])
    PairCons(Fst(#fterm), text⟦†⟨Snd(#fvar)⟩†⟨Snd(#fterm)⟩⟧)

  rule CppFreshesTerm(#env, cterm⟦ ##canno* ( f ##csortanno?[] ) ##cterm[f] ⟧)
  → CppFreshesTerm(AddVar(#env, var, Formal(text⟦ dummy ⟧, NONE)), #cterm[var])

  rule CppFreshesTerm(#env, cterm⟦ ##canno* { ##cmapentries? } ##csortanno? ⟧)
  → Error("Internal Error: map expression must no occur in the contraction.")

  rule CppFreshesTerm(#env, cterm⟦ ##canno* thunk ##cterm ⟧)
  → CppFreshesTerm(#env, #cterm)

  rule CppFreshesTerm(#env, cterm⟦ ##canno* let ##METAVAR ##csortanno? = ##cterm ##cterm2 ⟧)
  → let #fterm1 = CppFreshesTerm(#env, #cterm)
    let #fterm2 = CppFreshesTerm(Fst(#fterm1), #cterm2)
    PairCons(Fst(#fterm2), text⟦†⟨Snd(#fterm1)⟩†⟨Snd(#fterm2)⟩⟧)

func CppFreshesMaybeTerms({String : EnvEntry}, List<Core_cterms_sort>) -> PPair<{String : EnvEntry} Text4_text_sort>
rule CppFreshesMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧) → CppFreshesTerms(#env, #cterm*)
rule CppFreshesMaybeTerms(#env, #cterms?              ) → PairCons(#env, text⟦⟧)

func CppFreshesTerms({String : EnvEntry}, List<Core_cterm_sort>) -> PPair<{String : EnvEntry} Text4_text_sort>

  rule CppFreshesTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧)
  → let #fterm = CppFreshesTerm(#env, #cterm)
    let #fterms = CppFreshesTerms(Fst(#fterm), #cterm*)
    PairCons(Fst(#fterms), text⟦†⟨Snd(#fterm)⟩†⟨Snd(#fterms)⟩⟧)

  rule CppFreshesTerms(#env, cterm*⟦⟧)
  → PairCons(#env, text⟦⟧)

func CppFreshesMaybeSubst({String : EnvEntry}, List<Core_csubst_sort>) -> PPair<{String : EnvEntry} Text4_text_sort>
rule CppFreshesMaybeSubst(#env, csubst?⟦              ⟧) → PairCons(#env, text⟦⟧)
rule CppFreshesMaybeSubst(#env, csubst?⟦ [ ##cterm* ] ⟧) → CppFreshesTerms(#env, #cterm*)

func CppFreshesVariable({String : EnvEntry}, Option<Core_canno_sort>, Option<VarEntry>, String, List<Core_csortanno_sort>,
                        Bool /*Fresh or Bound?*/) -> PPair<{String : EnvEntry} Text4_text_sort>

  // New fresh variable, no reuse
  rule CppFreshesVariable(#env, NONE, NONE, #var, csortanno?⟦ : ##csort ⟧, TRUE)
  → let #cppvar = text⟦fresh†⟨NumberToText(GetFreshCounter(#env))⟩⟧
    let #cpptype = CppType(#csort)
    let #ctx = GetContext(#env)
    PairCons(IncFreshCounter(AddVar(#env, #var, Fresh(#cppvar, SOME(#csort)))),
             text⟦¶_C†⟨#cpptype⟩Var& †⟨#cppvar⟩ = var†⟨#cpptype⟩(†⟨#ctx⟩, †⟨Text-QuoteEscape(Show(#var))⟩);⟧)

  // New bound variable, no reuse
  rule CppFreshesVariable(#env, NONE, NONE, #var, csortanno?⟦ : ##csort ⟧, FALSE)
  → let #cppvar = text⟦bound†⟨NumberToText(GetCounter(#env))⟩⟧
    let #cpptype = CppType(#csort)
    let #ctx = GetContext(#env)
    PairCons(IncCounter(AddVar(#env, #var, Bound(#cppvar, SOME(#csort)))),
             text⟦¶_C†⟨#cpptype⟩Var& †⟨#cppvar⟩ = var†⟨#cpptype⟩(†⟨#ctx⟩, †⟨Text-QuoteEscape(Show(#var))⟩);⟧)

  // Fresh variable, reuse binder
  rule CppFreshesVariable(#env, SOME(canno⟦ @Reuse( ##METAVAR, ##NUMBER ) ⟧), NONE, #var, csortanno?⟦ : ##csort ⟧, TRUE)
  →  PairCons(AddVar(#env, #var, Fresh(GetMetaArgsAt(#env, #METAVAR, ToInteger(#NUMBER)), SOME(#csort))), text⟦⟧)

  // New bound variable, reuse binder
  rule CppFreshesVariable(#env, SOME(canno⟦ @Reuse( ##METAVAR, ##NUMBER ) ⟧), NONE, #var, csortanno?⟦ : ##csort ⟧, FALSE)
  →  PairCons(AddVar(#env, #var, Bound(text⟦dummy⟧, SOME(#csort))), text⟦⟧)

 // Variable already exists
 rule CppFreshesVariable(#env, #canno, SOME(#), #var, #csortanno?, #fresh)
  → PairCons(#env, text⟦⟧)

// ---- Generate term code - Produces statements and return expression

type CppExprResult = Tuple3<{String : EnvEntry} Text4_text_sort /* Expression */ Text4_text_sort /* Statement */>

func CppExprTerm({String : EnvEntry}, Core_cterm_sort) -> Tuple3<{String : EnvEntry} Text4_text_sort Text4_text_sort>

 rule CppExprTerm(#env, cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧)
 → CppExprConstruction(#env, #canno*, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?)

 rule CppExprTerm(#env, cterm⟦ ##canno* ##cliteral ⟧)
 → Tuple3(#env, text⟦†⟨CppExprLiteral(#env, #cliteral)⟩⟧, text⟦⟧)

 rule CppExprTerm(#env, cterm⟦ ##canno* ##VARIABLE ##csortanno? ⟧)
 → CppExprMaybeVar(#env, #canno*, MaybeGetVar(#env, #VARIABLE), #VARIABLE)

 rule CppExprTerm(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧)
 → CppExprMeta(#env, #canno*, #METAVAR, #cterms?, #csubst?)

 rule CppExprTerm(#env, cterm⟦ ##canno* [ x ##csortanno? ] ##cterm[x] ⟧)
 → CppExprBoundVar(#env, GetAnnotation("Reuse", #canno*), #csortanno?, [x]->#cterm[x])

 rule CppExprTerm(#env, cterm⟦ ##canno* ( f ##csortanno? ) ##cterm[f] ⟧)
 → CppExprLambda(HasAnnotation("NoLambda", #canno*), #env, cterm⟦ ##canno* ( f ##csortanno? ) ##cterm[f] ⟧)

// TODO: reuse thunk
 rule CppExprTerm(#env, cterm⟦ ##canno* thunk ##cterm ⟧)
 → let #lambda = CppExprLambdaNew(#env, #cterm, 0)
  Tuple3(First3(#lambda), text⟦thunk†⟨CppLambdaTypeArgs(#cterm)⟩(†⟨Second3(#lambda)⟩)⟧, Third3(#lambda))

 rule CppExprTerm(#env, cterm⟦ ##canno* let ##METAVAR ##csortanno? = ##cterm ##cterm2 ⟧)
 → Error("Error: Let expression cannot occur within another expression: it must be a the top-level expression.")

/* */
func CppExprMayInline(Bool, {String : EnvEntry}, Text4_text_sort) -> Tuple3<{String : EnvEntry} Text4_text_sort Text4_text_sort>

  rule CppExprMayInline(TRUE, #env, #expr)
  → Tuple3(#env, #expr, text⟦⟧)

  rule CppExprMayInline(FALSE, #env, #expr)
  → Tuple3(#env, text⟦⟨STRING: var:String⟩⟧, text⟦¶auto& ⟨STRING: Show(var)⟩ = †⟨#expr⟩;⟧)

// ---- construction expression

func CppExprConstruction({String : EnvEntry}, List<Core_canno_sort>, String,  List<Core_csortargs_sort>, List<Core_cterms_sort>, List<Core_csortanno_sort>)
                         -> Tuple3<{String : EnvEntry} Text4_text_sort Text4_text_sort>

// TODO: type arguments are only needed when the return type is a type variable. The rest should be deducable.
 rule CppExprConstruction(#env, #canno*, #constructor, #csortargs?, #cterms?, #csortanno?)
 → let #inline = IsInline(#env)
   let #args  = CppExprMaybeTerms(#env, #cterms?)
   let #expr = CppExprMayInline(#inline, First3(#args), text⟦†⟨CppConsMethodName(#constructor, HasAnnotation("Data", #canno*))⟩†⟨CppMaybeTypeArgs(#csortargs?)⟩(ctx†⟨Second3(#args)⟩)⟧)
   Tuple3(First3(#expr), Second3(#expr), text⟦†⟨Third3(#args)⟩†⟨Third3(#expr)⟩⟧)

func CppExprMaybeTerms({String : EnvEntry}, List<Core_cterms_sort>) -> Tuple3<{String : EnvEntry} Text4_text_sort Text4_text_sort>
rule CppExprMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧) → CppExprTerms(UnsetInline(#env), #cterm*)
rule CppExprMaybeTerms(#env, #cterms?              ) → Tuple3(#env, text⟦⟧, text⟦⟧)

func CppExprTerms({String : EnvEntry}, List<Core_cterm_sort>) -> Tuple3<{String : EnvEntry} Text4_text_sort Text4_text_sort>

  rule CppExprTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧)
  → let #expr = CppExprTerm(#env, #cterm)
    let #exprs = CppExprTerms(First3(#expr), #cterm*)
    Tuple3(First3(#exprs), text⟦, †⟨Second3(#expr)⟩†⟨Second3(#exprs)⟩⟧, text⟦†⟨Third3(#expr)⟩†⟨Third3(#exprs)⟩⟧)

    rule CppExprTerms(#env, cterm*⟦⟧)
    → Tuple3(#env, text⟦⟧, text⟦⟧)

// --- Variable

func CppExprMaybeVar({String : EnvEntry}, List<Core_canno_sort>, Option<VarEntry>, String) -> Tuple3<{String : EnvEntry} Text4_text_sort Text4_text_sort>

 rule CppExprMaybeVar(#env, #canno*, SOME(Formal(#var, #type)), #svar)
 → if HasAnnotation("Keep", #canno*)
     CppExprMayInline(IsInline(#env), #env, text⟦tosca::NewRef(†⟨#var⟩)⟧)
   else
     Tuple3(#env, #var, text⟦⟧)

 // fallback
 rule CppExprMaybeVar(#env, #canno*, SOME(#varEntry), #svar)
 → Tuple3(#env, text⟦†⟨UnVarVar(#varEntry)⟩.Use(ctx)⟧, text⟦⟧)


// ----  metavar expression

func CppExprMeta({String : EnvEntry}, List<Core_canno_sort>, String, List<Core_cterms_sort>, List<Core_csubst_sort>) -> Tuple3<{String : EnvEntry} Text4_text_sort Text4_text_sort>

 // No arguments -> just return the metavariable.
 rule CppExprMeta(#env, #canno*, #metavar, cterms?⟦⟧, csubst?⟦⟧)
 → CppExprRefMeta(#env, #canno*, #metavar, text⟦⟧)

 // No arguments in parenthesis -> call lambda with no param.
 rule CppExprMeta(#env, #canno*, #metavar, cterms?⟦ () ⟧, csubst?⟦⟧)
 → CppExprRefMeta(#env, #canno*, #metavar, text⟦.Eval(ctx)⟧)

 // Apply arguments -> call lambda
 rule CppExprMeta(#env, #canno*, #metavar, cterms?⟦ ( ##cterm* ) ⟧, csubst?⟦⟧)
 → let #exprs = CppExprTerms(UnsetInline(#env), #cterm*)
   let #metaexpr = CppExprRefMeta(First3(#exprs), #canno*, #metavar, text⟦.Eval(ctx†⟨Second3(#exprs)⟩)⟧)
   Tuple3(First3(#metaexpr), Second3(#metaexpr), text⟦†⟨Third3(#exprs)⟩†⟨Third3(#metaexpr)⟩⟧)

 // Maybe Substitution
 rule CppExprMeta(#env, #canno*, #metavar, cterms?⟦⟧, csubst?⟦ [ ##cterm* ] ⟧)
 → if HasAnnotation("NoSubst", #canno*)
     CppExprRefMeta(#env, #canno*, #metavar, text⟦⟧) // No need to substitute.
   else
     CppExprMetaSubst(#env, #canno*, #metavar, #cterm*)

// Meta-application with Substitution
func CppExprMetaSubst(#env: {String : EnvEntry}, #canno*: List<Core_canno_sort>, #metavar: String, #cterm*: List<Core_cterm_sort>)
                      -> Tuple3<{String : EnvEntry} Text4_text_sort Text4_text_sort>
→ let #metaargs = GetMetaArgs(#env, #metavar)
  let #args = CppExprMetaArgs(#env, #cterm*, text⟦⟧)
  let #metaexpr = CppExprRefMeta(First3(#args), #canno*, #metavar, text⟦⟧)
  Tuple3(First3(#metaexpr),
        text⟦⟨STRING: var:String⟩⟧,
        text⟦†⟨Third3(#args)⟩†⟨Third3(#metaexpr)⟩¶auto& ⟨STRING: var⟩ = Subst(ctx, †⟨Second3(#metaexpr)⟩, { †⟨TextMapFold((b)->text⟦&†⟨b⟩⟧, #metaargs, text⟦, ⟧)⟩ }, { †⟨Second3(#args)⟩ });⟧)

func CppExprMetaArgs({String : EnvEntry}, List<Core_cterm_sort> /* contraction args */, Text4_text_sort)
                     -> Tuple3<{String : EnvEntry} Text4_text_sort Text4_text_sort>

  rule CppExprMetaArgs(#env, (#arg, #args...), #sep)
  → let #arg = CppExprTerm(#env, #arg)
    let #args = CppExprMetaArgs(First3(#arg), #args, text⟦, ⟧)
    Tuple3(First3(#args), text⟦†⟨#sep⟩&†⟨Second3(#arg)⟩†⟨Second3(#args)⟩⟧, text⟦†⟨Third3(#arg)⟩†⟨Third3(#args)⟩⟧)

  rule CppExprMetaArgs(#env, (), #sep)
  → Tuple3(#env, text⟦⟧, text⟦⟧)

// Helper generating code adding a new term reference when @Keep is present.
func CppExprRefMeta(#env: {String: EnvEntry}, #canno*: List<Core_canno_sort>, #metavar: String, #suffix: Text4_text_sort)
                    -> Tuple3<{String : EnvEntry} Text4_text_sort Text4_text_sort>
→ if HasAnnotation("Keep", #canno*)
    Tuple3(#env,
           text⟦⟨STRING: var:String⟩⟧,
           text⟦¶auto& ⟨STRING: var⟩ = tosca::NewRef(†⟨GetMetaVar(#env, #metavar)⟩)†⟨#suffix⟩;⟧)
  else
    Tuple3(#env, text⟦†⟨GetMetaVar(#env, #metavar)⟩†⟨#suffix⟩⟧, text⟦⟧)

// ---- bound variable

func CppExprBoundVar({String : EnvEntry}, Option<Core_canno_sort>, List<Core_csortanno_sort>, [String]->Core_cterm_sort)
                     -> Tuple3<{String : EnvEntry} Text4_text_sort Text4_text_sort>

  // Binder is not reused. Get the new binder created during the fresh variable phase.
  rule CppExprBoundVar(#env, NONE, #csortanno?, [x]->#cterm[x])
  → let #counter = NumberToText(GetCounter(#env))
    let #boundvar = text⟦bound†⟨#counter⟩⟧ // already declared.
    let #term = CppExprTerm(AddVar(IncCounter(#env), var, Bound(#boundvar, MaybeSortAnnoToSort(#csortanno?))), #cterm[var])
    Tuple3(First3(#term), text⟦tosca::NewRef(†⟨#boundvar⟩), †⟨Second3(#term)⟩⟧, Third3(#term))

  // Binder is reused. Make sure to add a reference.
  rule CppExprBoundVar(#env, SOME(canno⟦ @Reuse( ##METAVAR, ##NUMBER ) ⟧), #csortanno?, [x]->#cterm[x])
  → let #reusecppvar = GetMetaArgsAt(#env, #METAVAR, ToInteger(#NUMBER))
    let #term = CppExprTerm(AddVar(#env, var, Bound(#reusecppvar, MaybeSortAnnoToSort(#csortanno?))), #cterm[var])
    Tuple3(First3(#term), text⟦tosca::NewRef(†⟨#reusecppvar⟩), †⟨Second3(#term)⟩⟧, Third3(#term))

// ---- lambda expression

func CppExprLambda(Bool /* Reuse? */, {String : EnvEntry}, Core_cterm_sort) -> Tuple3<{String : EnvEntry} Text4_text_sort Text4_text_sort>

  // Can be reuse: skip the formal arguments
  rule CppExprLambda(TRUE, #env, #cterm)
  → CppExprLambdaReuse(#env, StripBinders(#cterm))

  // Can't reuse it, so create...
  rule CppExprLambda(FALSE, #env, #cterm)
  → let #lambda = CppExprLambdaNew(#env, #cterm, 0)
    Tuple3(First3(#lambda),
           text⟦closure†⟨CppLambdaTypeArgs(#cterm)⟩(†⟨Second3(#lambda)⟩)⟧,
           Third3(#lambda))

func CppExprLambdaNew({String : EnvEntry}, Core_cterm_sort, Numeric) -> Tuple3<{String : EnvEntry} Text4_text_sort Text4_text_sort>

  rule CppExprLambdaNew(#env, cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #arity)
  → let #terms = CppExprTerms(#env, SubList(MaybeTermsToTerms(#cterms?), #arity))
    Tuple3(First3(#terms),
         text⟦&†⟨CppConsMethodName(#CONSTRUCTOR, HasAnnotation("Data", #canno*))⟩†⟨Second3(#terms)⟩⟧,
         Third3(#terms))

  rule CppExprLambdaNew(#env, cterm⟦ ##canno* ( f ##csortanno? ) ##cterm[f] ⟧, #arity)
  → CppExprLambdaNew(AddVar(#env, var, Formal(text⟦⟨STRING: var⟩⟧, MaybeSortAnnoToSort(#csortanno?))), #cterm[var], Plus(#arity, 1))

  rule CppExprLambdaNew(#env, #cterm, #arity)
  → Error("Internal Error: Invalid lambda expression. Lambda must be of the form (x .. y) -> C(x .. y, #1 .. #n)")

// Generate closure function type arguments. Not needed if the called function is not parameterized, C++ is capable of deducing types.
func CppLambdaTypeArgs(Core_cterm_sort) -> Text4_text_sort

  rule CppLambdaTypeArgs(cterm⟦ ##canno* ( f ##csortanno? ) ##cterm[f] ⟧)
  → CppLambdaTypeArgs(#cterm[dummy])

  rule CppLambdaTypeArgs(cterm⟦ ##canno* thunk ##cterm ⟧)
  → CppLambdaTypeArgs(#cterm)

  // Generate type arguments.
  rule CppLambdaTypeArgs(cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##csortargs ##cterms? : ##csort ⟧)
  → text⟦<†⟨TextFold((CppType(#csort), CppGetSortsMaybeTerms(#cterms?)...), text⟦, ⟧)⟩>⟧

  // No type arguments
  rule CppLambdaTypeArgs(cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##cterms? ##csortanno? ⟧)
  → text⟦⟧

  // No type arguments
  rule CppLambdaTypeArgs(cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧)
  → text⟦⟧

  rule CppLambdaTypeArgs(#cterm)
  → Error("Internal Error: Invalid lambda expression. Lambda must be of the form (x .. y) -> C(x .. y, #1 .. #n)")

func CppExprLambdaReuse({String : EnvEntry}, Core_cterm_sort) -> Tuple3<{String : EnvEntry} Text4_text_sort Text4_text_sort>

  // Lambda can be reuse. Must be a metavar
  rule CppExprLambdaReuse(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧)
  → CppExprMeta(#env, #canno*, #METAVAR, cterms?⟦⟧, csubst?⟦⟧)

  rule CppExprLambdaReuse(#env, #cterm)
  → Error("Internal Error: Cannot reuse a lambda expression that is not bound to a metavariable.")

func CppFindCptrMeta(#pairs:  List<PPair<List<Core_canno_sort> String>>, #METAVAR: String) -> PPair<List<Core_canno_sort> String>
→ UnSOME(PickFirst(#pairs, (annovar)->Equal(Snd(annovar), #METAVAR)))

// --- Literal

func CppExprLiteral({String : EnvEntry}, Core_cliteral_sort) -> Text4_text_sort
rule CppExprLiteral(#env, cliteral⟦ ##STRING ⟧) → CppLiteralId(GetURL(#env), #STRING)
//text⟦newStringTerm(ctx, †⟨Text-QuoteEscape(#STRING)⟩)⟧
rule CppExprLiteral(#env, cliteral⟦ ##NUMBER ⟧) → text⟦newDoubleTerm(ctx, ⟨STRING: #NUMBER⟩)⟧

// --- Sort translation functions

/* Generate template prefix for given sort variables */
func CppTemplatePrefix(List<Core_csortvars_sort>) -> Text4_text_sort

  rule CppTemplatePrefix(csortvars?⟦⟧) → text⟦⟧

  rule CppTemplatePrefix(csortvars?⟦ ∀ ##VARIABLE+ . ⟧)
  → text⟦¶template <†⟨CppTypeParameters(#VARIABLE+)⟩>⟧

/* Generate comma-seperated list of type parameters */
func CppTypeParameters(#vars: List<String>) -> Text4_text_sort
→ TextFold(Map((var) -> text⟦typename ⟨STRING: var⟩⟧, #vars), text⟦, ⟧)

/* Generate comma-separated list of type arguments from sort variables, if any*/
func MaybeCppTypeArguments(List<Core_csortvars_sort>) -> Text4_text_sort
rule MaybeCppTypeArguments(csortvars?⟦⟧) → text⟦⟧
rule MaybeCppTypeArguments(csortvars?⟦ ∀ ##VARIABLE+ . ⟧) → text⟦<†⟨CppTypeArguments(#VARIABLE+)⟩>⟧

/* Generate comma-separated list of type arguments from sort variables */
func CppTypeArguments(#vars: List<String>) -> Text4_text_sort
→ TextFold(Map<String Text4_text_sort>((var) -> text⟦⟨STRING: var⟩⟧, #vars), text⟦, ⟧)

/* Generate (possibility dependent) type name corresponding to the given data sort type */
func CppTypeName(List<Core_csortvars_sort>, String) -> Text4_text_sort

  rule CppTypeName(csortvars?⟦⟧, #sortname)
  → SortNameToCppClassName(#sortname)

  //TODO: might need typename when occurs within a template class.
  rule CppTypeName(csortvars?⟦ ∀ ##VARIABLE+ . ⟧, #sortname)
  → text⟦†⟨SortNameToCppClassName(#sortname)⟩<†⟨CppTypeArguments(#VARIABLE+)⟩>⟧

/* Generate (possibility dependent) type name corresponding to the given data sort type */
func CppTypeRefName(#csortvars?: List<Core_csortvars_sort>, #sortname:String) -> Text4_text_sort
→ text⟦†⟨CppTypeName(#csortvars?, #sortname)⟩&⟧

/* Generate arguments for template instantiation */
func MaybeCppTemplateArgs(List<Core_csorts_sort>) -> Text4_text_sort

    rule MaybeCppTemplateArgs(csorts?⟦ ⟧)
    → text⟦⟧

    rule MaybeCppTemplateArgs(csorts?⟦ ( ##csort* )⟧)
    → text⟦<†⟨TextFold(Map((csort) -> CppType(csort), #csort*), text⟦, ⟧)⟩>⟧

/* Convert list of sorts to a list of formal parameters or arguments. */
func MaybeCppFormalParams(List<Core_csorts_sort>, Text4_text_sort, Bool /* omit types */) -> Text4_text_sort

  rule MaybeCppFormalParams(csorts?⟦⟧, #sep, #isarg)
  → text⟦⟧

  rule MaybeCppFormalParams(csorts?⟦ ( ##csort*) ⟧, #sep, #isarg)
  → CppFormalParams(#csort*, 1, #sep, #isarg)

func CppFormalParams(List<Core_csort_sort>, Numeric, Text4_text_sort, Bool) -> Text4_text_sort

  rule CppFormalParams(csort*⟦⟧, #index, #sep, #isarg)
  → text⟦⟧

  rule CppFormalParams(csort*⟦ ##csort ##csort* ⟧, #index, #sep, #isarg)
  → text⟦†⟨#sep⟩†⟨CppFormalParam(CppTypes(#csort), #index, 1, #isarg)⟩†⟨CppFormalParams(#csort*, Plus(#index, 1), text⟦, ⟧, #isarg)⟩⟧

func CppFormalParam(List<Text4_text_sort>, Numeric, Numeric, Bool) -> Text4_text_sort

  rule CppFormalParam(Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #index, #subindex, #isarg)
  → text⟦†⟨If(#isarg, ()->text⟦⟧, ()->text⟦†⟨#type⟩& ⟧)⟩†⟨ParamName(#index)⟩⟧

  rule CppFormalParam(Cons(#type:Text4_text_sort, #types:List<Text4_text_sort>), #index, #subindex, #isarg)
  → text⟦†⟨If(#isarg, ()->text⟦⟧, ()->text⟦†⟨#type⟩& ⟧)⟩†⟨VarParamName(#index, #subindex)⟩, †⟨CppFormalParam(#types, #index, Plus(#subindex, 1), #isarg)⟩⟧

func ParamName(#index: Numeric) -> Text4_text_sort
→ text⟦param†⟨NumberToText(#index)⟩⟧

func VarParamName(#index: Numeric, #subindex: Numeric) -> Text4_text_sort
→ text⟦param†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩⟧

/* Translate TS sort to equivalent list of C++ types:
 * A list of types corresponding to syntactic variable sorts and a type for the last sort
 * Note: return a type, not a type reference
 */
func CppTypes(#csort: Core_csort_sort) -> List<Text4_text_sort>
→ CppTypes2(#csort, ())

func CppTypes2(Core_csort_sort, List<Text4_text_sort> /* formal params */) -> List<Text4_text_sort>

  rule CppTypes2(csort⟦ ##canno* ##CONSTRUCTOR ##csorts? ⟧, ())
  → (text⟦†⟨SortNameToCppClassName(CppFixupPrimitiveType(#CONSTRUCTOR))⟩†⟨MaybeCppTemplateArgs(#csorts?)⟩⟧,)

  rule CppTypes2(csort⟦ ##canno* ##CONSTRUCTOR ##csorts? ⟧, (#formal, #formals...))
  → (text⟦Closure†⟨NumberToText(Plus(ListLength<Text4_text_sort>(#formals), 1))⟩<†⟨
       SortNameToCppClassName(CppFixupPrimitiveType(#CONSTRUCTOR))⟩†⟨MaybeCppTemplateArgs(#csorts?) /* Return type */⟩, †⟨
       TextFold(Cons(#formal, #formals), text⟦, ⟧) /* Formal params */⟩>⟧,)

  rule CppTypes2(csort⟦ ##canno* ##VARIABLE ⟧, ())
  → (text⟦⟨STRING: #VARIABLE⟩⟧,)

  rule CppTypes2(csort⟦ ##canno* ##VARIABLE ⟧, (#formal, #formals...))
  → (text⟦Closure†⟨NumberToText(Plus(ListLength(#formals), 1))⟩<⟨STRING: #VARIABLE /* Return type */⟩, †⟨
       TextFold((#formal, #formals...), text⟦, ⟧) /* Formal params */⟩>⟧,)

  rule CppTypes2(csort⟦ ##canno* [ ##csort ] ##csort2 ⟧, #formals)
  → Cons(text⟦_C†⟨CppType(#csort)⟩Var⟧, CppTypes2(#csort2, #formals)) // TODO: Var must be printed before template args.

  rule CppTypes2(csort⟦ ##canno* ( ##csort ) ##csort2 ⟧, #formals) // no higher-order csort for now.
  → CppTypes2(#csort2, Append(CppType(#csort), #formals))

  rule CppTypes2(csort⟦ ##canno* { ##csort1 : ##csort2 } ⟧, ())
  → Cons(text⟦MapTerm<†⟨CppType(#csort1)⟩,†⟨CppType(#csort2)⟩>⟧, Nil)

  rule CppTypes2(csort⟦ ##canno* { ##cmapsort } ⟧, Cons(#formal:Text4_text_sort, #formals:List<Text4_text_sort>))
  → Cons(text⟦Closure†⟨NumberToText(Plus(ListLength(#formals), 1))⟩<MapTerm, †⟨
       TextFold(Cons(#formal, #formals), text⟦, ⟧) /* Formal params */⟩>⟧, Nil)

  rule CppTypes2(csort⟦ ##canno* data ##csort ⟧, #formals)
  → CppTypes2(#csort, #formals)

  rule CppTypes2(csort⟦ ##canno* thunk ##csort ⟧, #formals)
  → Cons(text⟦Closure0<†⟨CppType(#csort)⟩>⟧, Nil)

/* Same as above, expect ignore syntactic variables */
func CppType(#csort: Core_csort_sort) -> Text4_text_sort
→ Last(CppTypes(#csort)) // TODO: could optimize

/* Same as above, but return a reference type */
func CppTypeRef(#csort: Core_csort_sort) -> Text4_text_sort
→ text⟦†⟨CppType(#csort)⟩&⟧

/* Same as above, expect maybe get a sort. Generate auto& when no type. */
func MaybeCppType(#csort?: Option<Core_csort_sort>) -> Text4_text_sort
→ IfPresent(Maybe((csort)->CppType(csort), #csort?), (type) -> type, () -> text⟦auto&⟧)

/* Same as above, expect with default value */
func MaybeCppTypeD(Option<Core_csort_sort>, Text4_text_sort) -> Text4_text_sort
rule MaybeCppTypeD(NONE        , #default) → #default
rule MaybeCppTypeD(SOME(#csort), #default) → CppType(#csort) // TODO: could optimize

/* Rename builtin types to avoid conflict with C++ types */
func CppFixupPrimitiveType(#typename: String) -> String
→ if      StringEqual(#typename, "String")     "StringTerm"
  else if StringEqual(#typename, "Numeric")    "DoubleTerm"
  else if StringEqual(#typename, "Appendable") "StringTerm"
  else                                         #typename

func CppMaybeTypeArgs(List<Core_csortargs_sort>) -> Text4_text_sort
rule CppMaybeTypeArgs(csortargs?⟦              ⟧) → text⟦⟧
rule CppMaybeTypeArgs(csortargs?⟦ < ##csort* > ⟧) → text⟦<†⟨TextFold(Map((csort)->CppType(csort), #csort*), text⟦, ⟧)⟩>⟧

/* Extract sorts from the given optional list of arguments */
func CppGetSortsMaybeTerms(List<Core_cterms_sort>) -> List<Text4_text_sort>
rule CppGetSortsMaybeTerms(cterms?⟦ ( ##cterm* ) ⟧ ) → CppGetSortsTerms(#cterm*)
rule CppGetSortsMaybeTerms(#cterms?               ) → ()

func CppGetSortsTerms(#terms: List<Core_cterm_sort>) -> List<Text4_text_sort>
→ Map((term) -> IfPresent(TermSort(term), (sort)->CppType(sort), ()->Error("Internal Error: missing sort.")), #terms)

// --- Basic conversion functions

/* Convert data sort name to corresponding C++ class name */
func SortNameToCppClassName(#name: String) -> Text4_text_sort
→ if Equal(#name, "STRING")
    text⟦ESTRING⟧
  else if Equal(#name, "Term")
    text⟦tosca::Term⟧
  else
    text⟦⟨STRING: Mangle(#name)⟩⟧

/* Convert data sort name to equivalent C++ class name reference */
func SortNameToCppClassNameRef(#name: String) -> Text4_text_sort
→ text⟦†⟨SortNameToCppClassName(#name)⟩&⟧

/* Convert the given contructor (function or data) to corresponding C++ method name */
func CppConsMethodName(#name: String, #isdata: Bool) -> Text4_text_sort
→ text⟦†⟨TextIf(#isdata, ()->text⟦new⟧)⟩⟨STRING: Mangle(#name)⟩⟧

/* Convert data form to corresponding C++ constructor method name */
func CppNewMethodName(#name: String) -> Text4_text_sort
→ text⟦new⟨STRING: Mangle(#name)⟩⟧

/* Convert data form to corresponding C++ 'as' method name */
func CppAsMethodName(#name: String) -> Text4_text_sort
→ text⟦as⟨STRING: Mangle(#name)⟩⟧

/* Convert parameterized data form to corresponding C++ class name */
func ParamFormCppClassName(#name: String, #csortvars?: List<Core_csortvars_sort>, #kind: CppFormClassKind) -> Text4_text_sort
→ text⟦†⟨FormCppClassName(#name)⟩†⟨CppFormClassSuffix(#kind)⟩†⟨MaybeCppTypeArguments(#csortvars?)⟩⟧

/* Convert data form to corresponding C++ class name */
func FormCppClassName(#name: String) -> Text4_text_sort
→ If(Equal(#name, "STRING"), ()->text⟦CSTRING⟧, ()->text⟦_C⟨STRING: Mangle(#name)⟩⟧)

/* Convert data form to corresponding C++ class name reference */
func FormCppClassNameRef(#name: String) -> Text4_text_sort
→ text⟦†⟨FormCppClassName(#name)⟩&⟧

/* Convert TS function name to corresponding C++ function name  */
func CppFnName(#name: String) -> Text4_text_sort
→ text⟦⟨STRING: Mangle(#name)⟩⟧

/* Print form class suffix based of the given `#kind` */
func CppFormClassSuffix(CppFormClassKind) -> Text4_text_sort
rule CppFormClassSuffix(CFC_CONS)   → text⟦⟧
rule CppFormClassSuffix(CFC_VAR)    → text⟦Var⟧
rule CppFormClassSuffix(CFC_VARUSE) → text⟦Use⟧

/* Literal id */
func CppLiteralId(#url:String, #str:String) -> Text4_text_sort
→ text⟦_l_⟨STRING: Mangle(PathFileStem(#url))⟩_⟨STRING: Mangle(#str)⟩⟧

// --- helper function

/* Whether to generate function body */
func GenBody(#csortvars? : List<Core_csortvars_sort>, #header : Bool, #forward: Bool) -> Bool
→ And(
    Not(#forward),
    Or(
      And(IsEmpty   (#csortvars?), Not(#header)),
      And(IsNotEmpty(#csortvars?), #header)))

/* Generate method qualifier, only for definitions */
func CppQualifier(#sortname: String, #csortvars? : List<Core_csortvars_sort>, #def : Bool) -> Text4_text_sort
→ TextIf(#def, ()->text⟦†⟨CppTypeName(#csortvars?, #sortname)⟩::⟧)

/* Generate form class qualifier, only for definitions */
func CppFormQualifier(#formname: String, #csortvars? : List<Core_csortvars_sort>, #kind: CppFormClassKind, #def : Bool) -> Text4_text_sort
→ TextIf(#def, ()->text⟦†⟨ParamFormCppClassName(#formname, #csortvars?, #kind)⟩::⟧)
